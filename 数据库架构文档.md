# 数据库架构文档

## 概述

本项目基于 SurrealDB 构建，采用图数据库架构管理复杂的工厂工程设计数据。系统通过统一的 PE（Plant Element）表存储所有工程元素，结合关系表和类型表，实现高效的层次化数据管理和查询。

## 核心架构设计

### 1. 数据库层次结构

```
MDB (多数据库)
 └─ WORL (世界节点, dbnum 标识)
     └─ SITE (站点)
         └─ ZONE (区域)
             └─ EQUI (设备)
                 └─ PIPE (管道)
```

### 2. 表结构设计

#### PE 表（核心存储表）
- **作用**: 统一存储所有类型的工厂工程元素
- **关键字段**:
  - `id`: 记录唯一标识符
  - `refno`: RefU64 类型，通过 `RefNo` 结构体存储，包含 `dbnum、sesno、deleted` 等字段
  - `noun`: 元素类型（如 'SITE', 'ZONE', 'EQUI', 'PIPE'）
  - `name`: 元素名称
  - `owner`: 父节点引用
  - `children`: 子节点集合
  - `deleted`: 逻辑删除标记
  - `op`: 操作类型（新增/修改/删除）
  - `sesno`: 会话编号

#### 类型表（WORL、SITE、ZONE、EQUI、PIPE等）
- **作用**: 存储特定类型的属性和元数据
- **关键特征**: `REFNO` 字段指向 pe 表中的记录
- **关系模式**: 类型表 → REFNO → pe 表

#### pe_owner 关系表
- **作用**: 表示 PE 元素之间的父子层级关系
- **关系方向**: `child (in) -[pe_owner]-> parent (out)`
- **字段说明**:
  - `in`: 子节点 (指向 pe 表中的记录)
  - `out`: 父节点 (指向 pe 表中的记录)

## 数据库查询模式和最佳实践

### 1. 图遍历查询语法

#### 正向遍历（查询子节点）
```sql
-- 查询父节点的直接子节点
SELECT VALUE in FROM pe_owner 
WHERE out = $parent_id AND in.deleted = false

-- 使用图遍历语法
SELECT value in FROM $parent_id<-pe_owner WHERE in.noun = 'SITE'
```

#### 反向遍历（查询父节点）
```sql
-- 查询子节点的父节点
SELECT VALUE out FROM pe_owner WHERE in = $child_id

-- 使用图遍历语法
SELECT value out FROM $child_id->pe_owner
```

#### 层级递归查询
```sql
-- 递归查询所有子孙节点
SELECT @.{1..20}->pe_owner->target FROM $root_node

-- 查询所有祖先节点
RETURN fn::ancestor($node).refno
```

### 2. 类型查询模式

#### 基础类型查询
```sql
-- 单一类型查询
SELECT value id FROM SITE WHERE REFNO.dbnum = 1112

-- 多类型联合查询
SELECT value id FROM pe WHERE noun IN ['SITE', 'ZONE'] AND dbnum = 1112
```

#### 条件过滤查询
```sql
-- 过滤有子节点的元素
SELECT value id FROM pe WHERE noun = 'ZONE' AND array::len(children) > 0

-- 名称模糊匹配
SELECT value REFNO FROM ZONE WHERE string::contains(NAME, $keyword)
```

### 3. 查询构建器使用

项目提供了专门的查询构建器，提高查询的一致性和可维护性：

```rust
// 基础查询构建
let query = QueryBuilder::new()
    .select("*")
    .from("pe")
    .where_clause("noun = 'PIPE'")
    .limit(10)
    .order_by("name", false);

// PE 专用查询
let pe_query = PeQueryBuilder::new(refno)
    .children_query();  // 查询子元素

// 函数查询
let fn_query = FunctionQueryBuilder::default_full_name(refno);
```

### 4. 批量查询优化

#### 批量类型查询
```sql
-- 使用逗号拼接表名查询多个类型
SELECT value REFNO FROM SITE, ZONE, EQUI WHERE REFNO.dbnum IN [1112, 1113]

-- 使用数组批量查询
SELECT value fn::default_full_name(id) FROM [pe:id1, pe:id2, pe:id3]
```

#### 批量关系查询
```sql
-- 批量查询所有子节点
array::flatten(
    SELECT value in FROM [pe:id1, pe:id2, pe:id3]<-pe_owner 
    WHERE record::exists(in.id) AND !in.deleted
)
```

## 函数库使用

### 1. 内置函数

#### 层次和名称相关
```sql
-- 获取祖先节点
RETURN fn::ancestor($pe).refno

-- 获取默认名称
RETURN fn::default_name($pe)

-- 获取完整名称
RETURN fn::default_full_name($pe)

-- 获取节点在同类型中的序号
RETURN fn::order($pe)
```

#### 数据库相关
```sql
-- 根据数据库编号获取 WORLD
RETURN fn::get_world(1112)

-- 查询 WORLD 下的所有 SITE
RETURN fn::query_sites_of_db($world_refno)

-- 直接通过数据库编号获取 SITE
RETURN fn::get_sites_of_dbnum(1112)
```

### 2. 数据备份和恢复

#### 自动备份函数
```sql
-- 备份修改的数据
fn::backup_data($pes, $is_del, $sesno)

-- 备份所有权关系
fn::backup_owner_relate($pes, $delete_old)
```

## 数据库配置

### 1. 连接配置
```toml
# DbOption.toml
mdb_name = "651YK"
surreal_ns = 1500
project_name = "YCYK-E3D"
location_dbs = [1112]
```

### 2. 数据库类型
```rust
#[repr(u8)]
pub enum DBType {
    DESI = 1,  // 设计数据库
    CATA = 2,  // 目录数据库
    PROP = 3,  // 属性数据库
    ISOD = 4,  // ISO图数据库
    PADD = 5,  // 管道数据库
    DICT = 6,  // 字典数据库
    ENGI = 7,  // 工程数据库
    SCHE = 14, // 图纸数据库
}
```

## 查询注意事项

### 1. 性能优化

#### 优先使用 PE 表
- 直接查询 `pe` 表比循环查询多个类型表更高效
- 使用 `noun IN [...]` 条件一次性获取多种类型数据

#### 合理使用索引
- 确保 `dbnum、noun、deleted` 等关键字段有索引
- 对名称查询建立适当的文本索引

#### 缓存机制
- 使用 `#[cached]` 宏缓存频繁查询的结果
- 合理设置缓存过期时间

### 2. 查询安全

#### 记录存在性检查
```sql
-- 使用 record::exists 确保记录存在
WHERE record::exists(pe) AND !pe.deleted

-- 避免查询已删除的记录
WHERE deleted = false
```

#### 类型转换安全
```rust
// 安全的类型转换
let refnos: Vec<RefnoEnum> = response.take(0)?;
let result: Option<SPdmsElement> = response.take(0)?;
```

### 3. 错误处理

#### 查询结果验证
```rust
// 检查查询结果是否存在
let result: Option<SPdmsElement> = SUL_DB.query_take(sql, 0).await?;
if let Some(pe) = result {
    // 处理有效结果
}
```

#### 错误传播
- 使用 `anyhow::Result<T>` 进行统一的错误处理
- 在错误信息中包含 SQL 语句和调用位置信息

## 测试和开发

### 1. 内存数据库测试
项目提供完整的内存数据库测试环境，确保测试的独立性和可重复性：

```rust
// 初始化内存测试数据库
init_memory_test_surreal().await?;

// 执行测试
let mut test = Test::new(sql).await?;

// 清理测试数据
cleanup_memory_test_surreal().await?;
```

### 2. 测试最佳实践
- 每个测试使用独立的内存数据库
- 测试完成后自动清理数据
- 避免测试间的数据污染

## 层级查询模式详解

### 1. 递归遍历查询语法

#### SurrealDB 图遍历语法
```sql
-- 基本语法结构
@.{范围}+关系->目标字段

-- 使用 @.{..+collect+inclusive} 递归查询所有祖先节点
SELECT VALUE @.{..+collect+inclusive}.owner FROM ONLY $pe LIMIT 1

-- 递归查询子孙节点
@.{..+collect}.children
```

#### 层级范围控制
```sql
-- 固定深度查询（精确层数）
@.{2}children  -- 查询第2层子节点

-- 范围查询（最小..最大）
@.{1..5}children  -- 查询1到5层的子孙节点

-- 深度查询（无限层）
@.{..}children  -- 查询所有层级的子孙节点
```

### 2. 内置层级查询函数

#### ancestor 函数 - 查询祖先节点
```sql
-- 获取节点的所有祖先节点（不包括根节点和空节点）
DEFINE FUNCTION fn::ancestor($r: record) {
    return if !record::exists($r) {
        return [];
    } else {
        let $nodes = (SELECT VALUE @.{..+collect+inclusive}.owner FROM ONLY $r LIMIT 1) ?: [];
        return array::filter($nodes, |$v| $v != NONE && $v != pe:0_0);
    };
};

-- 使用示例
RETURN fn::ancestor($zone_refno);  -- 返回 ZONE 的所有祖先节点
```

#### collect_children 函数 - 收集子节点
```sql
-- 收集子节点，支持按类型过滤
DEFINE FUNCTION fn::collect_children($root: record, $types: option<array<string>>) {
    if !record::exists($root) {
        return [];
    };
    let $raw_children = (SELECT VALUE children FROM ONLY $root LIMIT 1) ?: [];
    let $children = array::flatten([$raw_children]);
    let $filtered = array::filter($children, |$child| $child != none);

    let $type_filter = $types ?: [];
    if array::len($type_filter) == 0 {
        return $filtered;
    } else {
        return array::filter($filtered, |$child| $child.noun IN $type_filter);
    };
};

-- 使用示例
RETURN fn::collect_children($site_refno, ["EQUI", "ZONE"]);  -- 获取所有 EQUI 和 ZONE 子节点
```

#### collect_descendant_infos 函数 - 深度子孙节点查询
```sql
-- 收集子孙节点信息，支持自定义递归深度和类型过滤
DEFINE FUNCTION fn::collect_descendant_infos(
    $root: record,
    $types: array<string>,
    $inclusive: option<bool>,
    $range_str: string,
) {
    let $use_inclusive = $inclusive ?:true;
    let $raw_descendants = if $use_inclusive {
        (SELECT VALUE array::flatten(@.{..+collect+inclusive}.children).{ id, noun } FROM ONLY $root LIMIT 1) ?: []
    } else {
        (SELECT VALUE array::flatten(@.{..+collect}.children).{ id, noun } FROM ONLY $root LIMIT 1) ?: []
    };
    -- 类型过滤和去重处理...
};

-- 使用示例
RETURN fn::collect_descendant_infos($site_refno, ["EQUI", "PIPE"], true, "..");
```

### 3. 项目封装的层级查询 API

#### Rust 层级查询函数
```rust
// 查询所有子孙节点（无类型过滤）
pub async fn query_deep_children_refnos(refno: RefnoEnum) -> anyhow::Result<Vec<RefnoEnum>>

// 带类型过滤的子孙节点查询
pub async fn query_filter_deep_children(refno: RefnoEnum, nouns: &[&str]) -> anyhow::Result<Vec<RefnoEnum>>

// 查询子孙节点的完整属性信息
pub async fn query_filter_deep_children_atts(refno: RefnoEnum, nouns: &[&str]) -> anyhow::Result<Vec<NamedAttrMap>>

// 查询子孙节点的完整元素信息
pub async fn query_ele_filter_deep_children(refno: RefnoEnum, nouns: &[&str]) -> anyhow::Result<Vec<SPdmsElement>>

// 支持层级范围控制的子孙节点查询  
pub async fn query_filter_deep_children_atts_with_range(
    refno: RefnoEnum,
    nouns: &[&str],
    range: Option<&str>,
) -> anyhow::Result<Vec<NamedAttrMap>>
```

#### 高层级封装函数
```rust
// 通用 grandchildren 查询（支持灵活的表达式）
pub async fn collect_descendant_with_expr<T: SurrealValue>(
    refnos: &[RefnoEnum],
    nouns: &[&str],
    range_str: Option<&str>,
    select_expr: &str,
) -> anyhow::Result<Vec<T>>

// 便利函数 - 根据 refno 查询 IDs
pub async fn collect_descendant_filter_ids(
    refnos: &[RefnoEnum],
    nouns: &[&str],
    range_str: Option<&str>,
) -> anyhow::Result<Vec<RefnoEnum>>

// 便利函数 - 查询完整元素
pub async fn collect_descendant_elements(
    refnos: &[RefnoEnum],
    nouns: &[&str],
    range_str: Option<&str>,
) -> anyhow::Result<Vec<SPdmsElement>>

// 便利函数 - 查询完整属性
pub async fn collect_descendant_full_attrs(
    refnos: &[RefnoEnum],
    nouns: &[&str],
    range_str: Option<&str>,
) -> anyhow::Result<Vec<NamedAttrMap>>
```

### 4. 实际使用示例

#### 基础层级查询
```rust
// 查询 SITE 下的所有 EQUI 节点
let equi_nodes = query_filter_deep_children(site_refno, &["EQUI"]).await?;

// 查询特定层级深度的节点（1-3层）
let ranged_nodes = query_filter_deep_children_atts_with_range(
    site_refno, 
    &["ZONE", "EQUI"], 
    Some("1..3")
).await?;

// 查询子孙节点的完整元素信息
let elements = collect_descendant_elements(&[site_refno], &["EQUI", "PIPE"], None).await?;
```

#### 批量层级查询
```rust
// 从多个起点同时查询
let all_children = collect_descendant_filter_ids(
    &[site1_refno, site2_refno], 
    &["ZONE"], 
    None
).await?;

// 查询子孙节点属性（支持泛型）
let zone_attrs: Vec<NamedAttrMap> = collect_descendant_full_attrs(
    &[root_refno], 
    &["ZONE"], 
    Some("1..5")
).await?;
```

#### 高级过滤查询
```rust
// 查询具有 SPRE/CATR 属性的子孙节点
let spre_nodes = query_deep_children_refnos_filter_spre(&[refno], false).await?;

// 查询具有装配关系的子孙节点
let inst_nodes = collect_descendant_ids_has_inst(
    &[], 
    &[], 
    false, 
    None
).await?;
```

### 5. 层级查询性能优化

#### 查询优化策略
1. **使用数据库端函数**：利用 `fn::collect_descendants_filter_spre` 等内置函数一次性完成过滤
2. **批量查询**：使用 `array::map + array::flatten + array::distinct` 模式减少网络往返
3. **合理设置缓存**：对频繁查询使用 `#[cached]` 宏缓存结果
4. **层级范围控制**：使用 `range_str` 参数限制查询深度，提高性能

#### 性能对比
- **旧实现**：多次往返查询，性能较低
- **新实现**：数据库端一次性处理，性能提升约 50%-90%
- **批量查询**：相比单点查询，减少 90%+ 的网络往返时间

### 6. 查询注意事项

#### 层级深度控制
```sql
-- 避免无限递归，设置合理的层级范围
-- 有限深度查询（推荐）
@.{1..10}children  -- 限制在10层内

-- 无限深度查询（谨慎使用）
@.{..}children     -- 可能导致性能问题
```

#### 记录存在性检查
```sql
-- 始终检查记录是否存在
DEFINE FUNCTION fn::collect_children($root: record, $types: option<array<string>>) {
    if !record::exists($root) {
        return [];
    };
    -- 继续处理...
};
```

#### 类型安全
```rust
// 使用泛型确保类型安全
pub async fn collect_descendant_with_expr<T: SurrealValue>(
    refnos: &[RefnoEnum],
    nouns: &[&str],
    range_str: Option<&str>,
    select_expr: &str,
) -> anyhow::Result<Vec<T>>

// 明确指定返回类型
let ids: Vec<RefnoEnum> = collect_descendant_with_expr(&[refno], &["SITE"], None, "VALUE id").await?;
let elements: Vec<SPdmsElement> = collect_descendant_with_expr(&[refno], &["EQUI"], None, "*").await?;
```

## 总结

本项目采用图数据库架构，通过 PE 表的统一设计和灵活的层级查询机制，实现了复杂的工厂工程数据管理。层级查询系统提供了从基础的图遍历到高级封装函数的完整解决方案，支持灵活的深度控制、类型过滤和批量查询。开发者应充分利用项目提供的查询构建器和层级查询函数库，遵循查询最佳实践，确保系统的性能和可维护性。
