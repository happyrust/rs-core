# SurrealDB 数据库查询总结

本文档总结了 rs-plant3d 项目中 SurrealDB 数据库的查询语法和使用模式。

---

## 目录

1. [数据库架构总览](#1-数据库架构总览)
2. [基础查询语法](#2-基础查询语法)
3. [Record ID 格式](#3-record-id-格式)
4. [图遍历语法](#4-图遍历语法)
5. [递归路径查询](#5-递归路径查询)
6. [数据库端函数](#6-数据库端函数)
7. [RELATE 关系语句](#7-relate-关系语句)
8. [TreeIndex 快速层级查询](#8-treeindex-快速层级查询)
9. [模型生成相关表查询](#9-模型生成相关表查询)
10. [批量查询优化](#10-批量查询优化)
11. [Rust API 封装](#11-rust-api-封装)
12. [性能优化最佳实践](#12-性能优化最佳实践)

---

## 1. 数据库架构总览

### 1.1 核心架构设计

本项目基于 SurrealDB 构建，采用图数据库架构管理复杂的工厂工程设计数据。系统通过统一的 **PE（Plant Element）表**存储所有工程元素，结合关系表和类型表，实现高效的层次化数据管理和查询。

#### 数据库层次结构

```
MDB (多数据库)
 └─ WORL (世界节点, dbnum 标识)
     └─ SITE (站点)
         └─ ZONE (区域)
             └─ EQUI (设备)
                 └─ PIPE (管道)
```

### 1.2 核心表结构

#### PE 表（核心存储表）

**作用**：统一存储所有类型的工厂工程元素

**ID 格式**：`pe:⟨dbnum_refno⟩`，例如 `pe:⟨21491_10000⟩`

**关键字段**：
- `id`: 记录唯一标识符（RefnoEnum 类型）
- `refno`: RefU64 类型，包含 `dbnum`、`sesno`、`deleted` 等字段
- `noun`: 元素类型（如 'SITE', 'ZONE', 'EQUI', 'PIPE', 'BOX', 'CYLI' 等）
- `name`: 元素名称
- `owner`: 父节点引用（指向 pe 表中的记录）
- `children`: 子节点集合（数组字段，存储子节点的 pe 记录引用）
- `deleted`: 逻辑删除标记
- `sesno`: 会话编号
- `dbnum`: 数据库编号

**查询示例**：
```sql
-- 查询所有 EQUI 类型的元素
SELECT * FROM pe WHERE noun = 'EQUI' AND deleted = false;

-- 查询特定数据库的元素
SELECT * FROM pe WHERE dbnum = 1112 AND noun IN ['SITE', 'ZONE'];
```

#### 类型表（WORL、SITE、ZONE、EQUI、PIPE 等）

**作用**：存储特定类型的属性和元数据

**关键特征**：
- `REFNO` 字段指向 `pe` 表中的记录
- 类型表通过 `REFNO` 引用 `pe` 表
- 类型表存储特定类型的扩展属性

**关系模式**：`类型表 → REFNO → pe 表`

**查询示例**：
```sql
-- 从类型表获取 pe 表引用
SELECT value REFNO FROM WORL WHERE REFNO.dbnum = 1112;

-- 类型表的 REFNO 可以直接用于 pe_owner 关系查询
LET $world_pe_id = (SELECT value REFNO from WORL WHERE ...)[0];
SELECT value in FROM $world_pe_id<-pe_owner WHERE in.noun = 'SITE';
```

#### pe_owner 关系表

**作用**：表示 PE 元素之间的父子层级关系

**关系方向**：`child (in) -[pe_owner]-> parent (out)`

**字段说明**：
- `in`: 子节点（指向 pe 表中的记录）
- `out`: 父节点（指向 pe 表中的记录）
- `id`: 关系记录的唯一标识符

**重要说明**：
- `pe_owner` 针对的是 `pe` 表之间的连接关系，不是针对具体类型表
- 查询子节点时必须使用 pe 表的 id
- 这是一个通用的关系表，适用于所有类型的 PE 元素

**查询示例**：
```sql
-- 查询子节点
SELECT VALUE in FROM pe:⟨123⟩<-pe_owner WHERE in.deleted = false;

-- 查询父节点
SELECT VALUE out FROM pe:⟨123⟩->pe_owner;

-- 反向遍历（查找所有指向该节点的关系）
SELECT * FROM pe:⟨123⟩<-pe_owner;
```

**⚠️ 性能提示**：对于层级查询，推荐使用 TreeIndex（详见 [第 8 章 TreeIndex 快速层级查询](#8-treeindex-快速层级查询)），性能提升 100 倍。

### 1.3 模型生成相关表

#### 表分类概览

**普通表 (NORMAL)**：
- `inst_geo` - 几何单元表（存储几何体的参数和状态）
- `inst_info` - 实例信息表（存储几何实例的元数据）
- `tubi_info` - 管道信息表

**关系表 (RELATION)**：
- `inst_relate` - 实例关系表（pe → inst_info）
- `geo_relate` - 几何关系表（inst_info → inst_geo）
- `inst_relate_aabb` - 实例包围盒关系表（pe → aabb）
- `inst_relate_bool` - 布尔运算关系表
- `inst_relate_cata_bool` - CATE 布尔运算关系表
- `neg_relate` - 负实体关系表（geo_relate → pe）
- `ngmr_relate` - NGMR 负实体关系表（geo_relate → pe）
- `tubi_relate` - 管道关系表（pe → inst_info/tubi_info）

#### 核心关系链

```
pe (PE 元素)
  ↓ inst_relate
inst_info (实例信息)
  ↓ geo_relate
inst_geo (几何数据)
```

#### geo_relate 表的 geo_type 字段

`geo_relate` 表中的 `geo_type` 字段用于区分不同类型的几何体记录：

| geo_type | 含义 | 是否导出 |
|----------|------|----------|
| `Pos` | 原始几何（未布尔运算） | ✅ 导出 |
| `DesiPos` | 设计位置 | ✅ 导出 |
| `CatePos` | 布尔运算后的结果 | ✅ 导出 |
| `Compound` | 组合几何体（包含负实体引用） | ❌ 不导出 |
| `CateNeg` | 负实体 | ❌ 不导出 |
| `CataCrossNeg` | 交叉负实体 | ❌ 不导出 |

**查询条件**：导出时使用 `geo_type IN ['Pos', 'DesiPos', 'CatePos']`

**注意**：实例级布尔运算完成后，需要更新 `geo_relate` 表：
1. 将原始几何的 `geo_type` 从 `Pos` 改为 `Compound`
2. 创建新的布尔结果记录，`geo_type = 'CatePos'`

### 1.4 辅助表

**变换和几何辅助表**：
- `trans` - 变换矩阵表（ID 格式：`trans:⟨hash⟩`）
- `aabb` - 包围盒表（ID 格式：`aabb:⟨hash⟩`）
- `vec3` - 向量表（ID 格式：`vec3:⟨hash⟩`）
- `pe_transform` - PE 变换表（SCHEMAFULL 类型）

**业务扩展表**：
- `tag_name_mapping` - 位号映射表（PE 到位号）
- `measurement` - 测量数据表
- `annotation` - 批注数据表
- `dbnum_info_table` - 数据库编号统计信息表
- `pbs` - PBS（产品分解结构）元素表
- `pbs_owner` - PBS 层级关系表

### 1.5 表关系图

```
                         ┌─────────────┐
                         │     pe      │
                         │ (元素主表)  │
                         └──────┬──────┘
                                │
        ┌───────────────┬───────┴───────┬───────────────┬─────────────────┐
        │               │               │               │                 │
        ▼               ▼               ▼               ▼                 ▼
 ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌───────────────┐
 │ inst_relate │ │ tubi_relate │ │ neg_relate  │ │ ngmr_relate │ │tag_name_mapping│
 │ (几何实例)  │ │ (管道直段)  │ │ (负实体)    │ │ (NGMR负实体)│ │  (位号映射)   │
 └──────┬──────┘ └─────────────┘ └─────────────┘ └─────────────┘ └───────────────┘
        │
        ▼
 ┌─────────────┐
 │  inst_info  │
 │ (实例信息)  │
 └──────┬──────┘
        │
        ▼
 ┌─────────────┐
 │  geo_relate │
 │ (几何关系)  │
 └──────┬──────┘
        │
        ▼
 ┌─────────────┐
 │   inst_geo  │
 │ (几何数据)  │
 └─────────────┘

        层级关系:
 ┌─────────────┐
 │     pe      │
 └──────┬──────┘
        │ pe_owner
        ▼
 ┌─────────────┐
 │     pe      │
 └─────────────┘
```

### 1.6 相关代码位置

**核心模块**：
- **表结构定义**: `rs-core/src/rs_surreal/inst.rs::init_model_tables()`
- **PE 查询**: `rs-core/src/rs_surreal/query.rs`
- **层级查询**: `rs-core/src/rs_surreal/graph.rs`
- **实例查询**: `rs-core/src/rs_surreal/inst.rs`
- **查询扩展**: `rs-core/src/rs_surreal/query_ext.rs`

**详细架构文档**：
- `rs-core/数据库架构文档.md` - 完整的数据库架构说明
- `rs-core/docs/数据库查询总结/数据库架构.md` - 表结构详细说明

---

## 2. 基础查询语法

### 1.1 执行查询

```rust
// 通过全局连接执行查询
let mut response = SUL_DB.query_response(&sql).await?;
let result = response.take::<Vec<T>>(0)?;

// 简化版本
let result: Vec<T> = SUL_DB.query_take(&sql, 0).await?;
```

### 1.2 SELECT 语句

```sql
-- 基础 SELECT
SELECT * FROM pe WHERE noun = 'BOX';

-- 选择特定字段
SELECT refno, name, noun FROM pe WHERE deleted = false;

-- 使用 VALUE 返回单列
SELECT VALUE id FROM pe WHERE noun IN ['BOX', 'CYLI'];

-- 从记录数组查询
SELECT * FROM [pe:⟨123⟩, pe:⟨456⟩];

-- ONLY 限定单条记录
SELECT * FROM ONLY pe:⟨123⟩ LIMIT 1;
```

### 1.3 条件过滤

```sql
-- WHERE 条件
SELECT * FROM pe WHERE noun = 'BRAN' AND deleted = false;

-- IN 操作符
SELECT * FROM pe WHERE noun IN ['BOX', 'CYLI', 'CONE'];

-- 范围查询
SELECT * FROM pe WHERE sesno >= 100 AND sesno <= 200;

-- 嵌套属性访问
SELECT * FROM pe WHERE refno.TYPE = 'EQUI' OR refno.TYPEX = 'EQUI';
```

---

## 3. Record ID 格式

### 2.1 标准格式

```sql
-- 使用尖括号包裹 ID
pe:⟨12345_67890⟩
inst_geo:⟨abc123hash⟩
aabb:⟨xyz789hash⟩
trans:⟨transform_hash⟩

-- 复合 ID（用于历史版本）
pe:⟨["12345_67890", 880]⟩
```

### 2.2 Rust 转换

```rust
// RefnoEnum 转 PE key
let pe_key = refno.to_pe_key();  // 返回 "pe:⟨12345_67890⟩"

// 原始 ID
let raw_id = record_id.to_raw();
```

### 2.3 动态构建 Record ID

```sql
-- 使用 type::record 函数
let $pe_id = type::record('pe', '12345_67890');
let $old_pe_id = type::record('pe', [$id, $sesno]);

-- 使用 record::id 获取 ID 部分
let $id_part = record::id($pe);
```

---

## 4. 图遍历语法

### 3.1 正向遍历（->）

```sql
-- 遍历单个关系
SELECT * FROM pe:⟨123⟩->inst_relate;

-- 链式遍历
SELECT * FROM pe:⟨123⟩->LSTU->CATR;

-- 获取关系终点
SELECT VALUE out FROM pe:⟨123⟩->tubi_relate;
```

### 3.2 反向遍历（<-）

```sql
-- 获取指向当前节点的关系
SELECT * FROM pe:⟨123⟩<-pe_owner;

-- 获取父节点
SELECT VALUE in FROM pe:⟨123⟩->pe_owner;

-- 获取所有子节点
SELECT VALUE in FROM pe:⟨123⟩<-pe_owner;
```

**⚠️ 层级关系查询迁移建议**：

对于**层级关系查询**（子节点、子孙节点、祖先节点），**推荐使用 TreeIndex** 替代 SurrealDB 关系表遍历：

| 旧方式（SurrealDB） | 新方式（TreeIndex） | 性能提升 |
|-------------------|-------------------|----------|
| `SELECT VALUE in FROM pe:⟨refno}⟩<-pe_owner` | `collect_children_filter_ids(refno, &[])` | **100 倍** |
| `SELECT VALUE array::flatten(@.{..+collect}.children)` | `collect_descendant_filter_ids(&[refno], &[], None)` | **100 倍** |
| `SELECT VALUE out FROM pe:⟨refno}⟩->pe_owner` | `query_filter_ancestors(refno, &[])` | **100 倍** |

详见 [第 8 章 TreeIndex 快速层级查询](#8-treeindex-快速层级查询)。

### 3.3 条件过滤遍历

```sql
-- 过滤已删除的节点
SELECT * FROM pe:⟨123⟩<-pe_owner[? !in.deleted];

-- 按类型过滤
SELECT VALUE in FROM pe:⟨123⟩<-pe_owner WHERE in.noun = 'BOX';

-- 复合条件
SELECT VALUE in FROM pe:⟨123⟩<-pe_owner
WHERE in.noun != 'ATTA' AND in.deleted != true;
```

### 3.4 Rust API 调用

#### 3.4.1 属性关系遍历（SurrealDB）

```rust
// 使用 query_single_by_paths 遍历属性关系（仍需通过 SurrealDB）
// 这些是 PDMS 属性关系，不是层级关系，因此不能使用 TreeIndex

// 查询几何成员关系（GMRE）和几何结构（GSTR）
let result = aios_core::query_single_by_paths(
    cata_refno,
    &["->GMRE", "->GSTR"],  // 属性关系遍历
    &["REFNO"],             // 要获取的字段
).await?;

// 查询离开点（LSTU）的元件库（CATR）关系
let catr = aios_core::query_single_by_paths(
    leave_refno,
    &["->LSTU->CATR"],      // 属性关系链式遍历
    &["REFNO"],
).await?;
```

**适用场景**：
- `->GMRE`, `->GSTR`: 几何属性关系
- `->LSTU->CATR`: 管道连接关系
- 其他 PDMS 属性关系（SPRE, CATR, GMRE, GSTR 等）

**注意**：这些属性关系查询**仍需要通过 SurrealDB**，因为 TreeIndex 只处理层级关系（父子），不处理属性引用关系。

#### 3.4.2 层级关系遍历（推荐使用 TreeIndex）

对于**层级关系查询**（子节点、子孙节点、祖先节点），**推荐使用 TreeIndex** 替代 SurrealDB 图遍历：

```rust
// ❌ 旧方式：使用 SurrealDB 图遍历（慢）
// SELECT VALUE in FROM pe:⟨refno}⟩<-pe_owner;
// 或通过 pe.children 递归查询

// ✅ 新方式：使用 TreeIndex（快 10-100 倍）
use aios_core::collect_children_filter_ids;
use aios_core::collect_descendant_filter_ids;
use aios_core::query_filter_ancestors;

// 查询子节点（单层）
let children = collect_children_filter_ids(refno, &["EQUI", "PIPE"]).await?;

// 查询子孙节点（多层）
let descendants = collect_descendant_filter_ids(&[refno], &["EQUI"], None).await?;

// 查询祖先节点
let ancestors = query_filter_ancestors(refno, &["ZONE", "SITE"]).await?;
```

**性能对比**：

| 查询类型 | SurrealDB 图遍历 | TreeIndex | 推荐 |
|---------|-----------------|-----------|------|
| 子节点查询 | `<-pe_owner` 关系表 | `collect_children_filter_ids` | ✅ TreeIndex |
| 子孙节点查询 | `@.{..}.children` 递归 | `collect_descendant_filter_ids` | ✅ TreeIndex |
| 祖先节点查询 | `owner` 向上遍历 | `query_filter_ancestors` | ✅ TreeIndex |
| 属性关系（GMRE/GSTR） | `->GMRE`, `->GSTR` | 不支持 | ⚠️ SurrealDB |
| 属性关系（LSTU/CATR） | `->LSTU->CATR` | 不支持 | ⚠️ SurrealDB |

**迁移建议**：
1. **层级查询**：优先使用 TreeIndex（`collect_*` 系列函数）
2. **属性关系**：继续使用 SurrealDB（`query_single_by_paths`）
3. **混合查询**：先通过 TreeIndex 获取层级，再通过 SurrealDB 查询属性

#### 3.4.3 层级关系查询迁移示例

**旧方式（SurrealDB 关系表）**：
```rust
// ❌ 旧方式：通过 pe_owner 关系表查询子节点
// SELECT VALUE in FROM pe:⟨refno}⟩<-pe_owner;

// ❌ 旧方式：通过递归查询子孙节点
// SELECT VALUE array::flatten(@.{..+collect}.children) FROM ONLY pe:⟨refno}⟩;
```

**新方式（TreeIndex）**：
```rust
// ✅ 新方式：使用 TreeIndex 查询子节点（快 100 倍）
use aios_core::collect_children_filter_ids;
let children = collect_children_filter_ids(refno, &["EQUI", "PIPE"]).await?;

// ✅ 新方式：使用 TreeIndex 查询子孙节点（快 100 倍）
use aios_core::collect_descendant_filter_ids;
let descendants = collect_descendant_filter_ids(&[refno], &["EQUI"], None).await?;

// ✅ 新方式：使用 TreeIndex 查询祖先节点（快 100 倍）
use aios_core::query_filter_ancestors;
let ancestors = query_filter_ancestors(refno, &["ZONE"]).await?;
```

**说明**：
- `pe_owner` 关系表的层级查询 → 改用 `collect_children_filter_ids`
- `@.{..}.children` 递归查询 → 改用 `collect_descendant_filter_ids`
- `owner` 向上遍历 → 改用 `query_filter_ancestors`

---

## 5. 递归路径查询（Recursive Path）

SurrealDB 提供了强大的递归路径查询语法，用于遍历图结构中的层级关系。

### 4.1 递归路径基础语法

递归路径使用 `{range+options}` 格式，放在字段访问表达式中：

```sql
-- 基本格式
@.{range+option1+option2}.field

-- @ 代表当前记录
-- range 指定递归深度范围
-- options 控制递归行为
-- field 是要递归访问的字段名
```

### 4.2 递归范围（Range）语法

| 格式 | 说明 | 示例 SQL |
|------|------|----------|
| `..` | 无限递归（默认） | `@.{..}.children` |
| `3` | 精确 N 层 | `@.{3}.children` |
| `1..5` | 从第 1 层到第 5 层 | `@.{1..5}.children` |
| `..5` | 从第 0 层到第 5 层 | `@.{..5}.children` |
| `3..` | 从第 3 层到无限 | `@.{3..}.children` |

### 4.3 递归选项（Options）

| 选项 | 说明 |
|------|------|
| `collect` | 收集所有层级的结果到数组中 |
| `inclusive` | 包含起始节点本身 |

**组合使用：**

```sql
-- 收集所有子孙（不包含根节点）
@.{..+collect}.children

-- 收集所有子孙（包含根节点）
@.{..+collect+inclusive}.children

-- 收集 1-5 层的子孙
@.{1..5+collect}.children
```

### 4.4 完整递归查询示例

#### 示例 1：获取所有子孙节点

```sql
-- 从根节点递归获取所有 children 字段，展平为数组
SELECT VALUE array::flatten(@.{..+collect}.children)
FROM ONLY pe:⟨12345⟩ LIMIT 1;
```

**执行过程：**

1. 从 `pe:⟨12345⟩` 开始
2. 递归访问每个节点的 `children` 字段
3. `collect` 将每层结果收集到数组
4. `array::flatten` 将嵌套数组展平

#### 示例 2：获取子孙节点的特定字段

```sql
-- 获取所有子孙的 id 和 noun
SELECT VALUE array::flatten(@.{..+collect+inclusive}.children).{ id, noun }
FROM ONLY $root LIMIT 1;
```

**返回结构：**

```json
[
  { "id": "pe:⟨100⟩", "noun": "BOX" },
  { "id": "pe:⟨101⟩", "noun": "CYLI" },
  { "id": "pe:⟨102⟩", "noun": "CONE" }
]
```

#### 示例 3：获取祖先链

```sql
-- 使用 owner 字段向上递归获取祖先
SELECT VALUE @.{..+collect+inclusive}.owner
FROM ONLY pe:⟨12345⟩ LIMIT 1;
```

### 4.5 与 pe_owner 关系表的区别

项目中有两种获取层级关系的方式：

#### 方式 1：通过 children 字段递归（推荐）

```sql
-- pe 表中存储了 children 数组字段
SELECT VALUE array::flatten(@.{..+collect}.children) FROM ONLY $root;
```

#### 方式 2：通过 pe_owner 关系表反向遍历

```sql
-- 获取所有指向 $root 的 pe_owner 关系的 in 端
SELECT VALUE in FROM $root<-pe_owner;
```

#### 对比

| 特性 | children 递归 | pe_owner 关系 |
|------|---------------|---------------|
| 性能 | 单次查询完成 | 需要多次遍历 |
| 深度控制 | 支持 range 语法 | 需要手动控制 |
| 数据一致性 | 依赖 children 字段 | 依赖关系表 |
| 适用场景 | 批量获取子孙 | 单层父子查询 |

### 4.6 递归范围字符串（range_str）参数

在 Rust API 中，`range_str` 参数用于动态控制递归深度：

| 参数值 | 说明 | 生成的 SQL |
|--------|------|------------|
| `None` | 无限递归（默认 ".."） | `@.{..+collect}` |
| `Some("..")` | 无限递归 | `@.{..+collect}` |
| `Some("3")` | 精确 3 层 | `@.{3+collect}` |
| `Some("1..5")` | 1 到 5 层 | `@.{1..5+collect}` |
| `Some("..5")` | 最多 5 层 | `@.{..5+collect}` |

### 4.7 核心递归语法总结

```sql
-- 标准递归收集模板
SELECT VALUE array::flatten(@.{RANGE+collect+OPTIONS}.FIELD).{ PROJECTIONS }
FROM ONLY $root LIMIT 1;

-- 其中：
-- RANGE: .., 3, 1..5, ..5 等
-- OPTIONS: inclusive（可选）
-- FIELD: children, owner 等递归字段
-- PROJECTIONS: id, noun, refno.* 等投影字段
```

### 4.8 fn::collect_descendant_ids_by_types

这是项目中最核心的递归查询函数：

```sql
-- 函数定义
DEFINE FUNCTION fn::collect_descendant_ids_by_types(
    $pe: record,           -- 起始节点
    $t: array,             -- 类型过滤数组
    $inclusive: option<bool>,  -- 是否包含根节点
    $range_str: string     -- 递归范围
) {
    let $infos = fn::collect_descendant_infos($pe, $t, $inclusive, $range_str);
    return array::map($infos, |$info| $info.id);
};
```

**内部实现（fn::collect_descendant_infos）：**

```sql
DEFINE FUNCTION fn::collect_descendant_infos(
    $root: record,
    $types: array<string>,
    $inclusive: option<bool>,
    $range_str: string,
) {
    if !record::exists($root) {
        return [];
    };

    let $use_inclusive = $inclusive ?: true;

    -- 核心递归查询语句
    let $raw_descendants = if $use_inclusive {
        (SELECT VALUE array::flatten(@.{..+collect+inclusive}.children).{ id, noun }
         FROM ONLY $root LIMIT 1) ?: []
    } else {
        (SELECT VALUE array::flatten(@.{..+collect}.children).{ id, noun }
         FROM ONLY $root LIMIT 1) ?: []
    };

    -- 类型过滤
    let $filtered = array::filter($raw_descendants, |$node|
        $node != NONE
        && $node.id != NONE
        && (array::len($types) == 0 || $node.noun IN $types)
    );

    return $filtered;
};
```

### 4.4 Rust 端调用模式

```rust
/// collect_descendant_with_expr - 泛型递归查询函数
pub async fn collect_descendant_with_expr<T: SurrealValue>(
    refnos: &[RefnoEnum],
    nouns: &[&str],
    range_str: Option<&str>,
    select_expr: &str,
) -> anyhow::Result<Vec<T>> {
    let nouns_str = rs_surreal::convert_to_sql_str_array(nouns);
    let types_expr = if nouns.is_empty() {
        "[]".to_string()
    } else {
        format!("[{}]", nouns_str)
    };

    let refno_keys: Vec<String> = refnos.iter().map(|r| r.to_pe_key()).collect();
    let refno_list = refno_keys.join(", ");
    let range = range_str.unwrap_or("..");

    // 生成的 SQL：
    let sql = format!(
        r#"
        let $ids = array::distinct(array::filter(array::flatten(array::map([{}], |$refno|
            fn::collect_descendant_ids_by_types($refno, {}, none, "{}")
        )), |$v| $v != none));
        SELECT {} FROM $ids;
        "#,
        refno_list, types_expr, range, select_expr
    );

    let result: Vec<T> = SUL_DB.query_take(&sql, 1).await?;
    Ok(result)
}
```

### 4.5 常用递归查询 API

```rust
// 查询深度子孙节点 ID
collect_descendant_filter_ids(&[refno], &["BOX", "CYLI"], None).await?;
collect_descendant_filter_ids(&[refno], &["BOX", "CYLI"], Some("1..5")).await?;

// 查询深度子孙节点完整元素
collect_descendant_elements(&[refno], &["EQUI"], None).await?;

// 查询深度子孙节点属性
collect_descendant_full_attrs(&[refno], &["ZONE"], Some("1..3")).await?;

// 查询可见几何子孙节点
query_visible_geo_descendants(refno, false, None).await?;

// 查询负实体几何子孙节点
query_negative_geo_descendants(refno, false, Some("1..3")).await?;

// 查询直接子节点（单层）
collect_children_filter_ids(refno, &["EQUI", "PIPE"]).await?;

// 查询祖先节点
query_filter_ancestors(refno, &["SITE", "ZONE"]).await?;
```

---

## 6. 数据库端函数

### 5.1 节点导航函数

```sql
-- 获取祖先节点
fn::ancestor($pe)

-- 获取子节点
fn::children($pe)
fn::first_child($pe)
fn::last_child($pe)
fn::collect_children($root, $types)

-- 获取兄弟节点
fn::prev_pe($pe)
fn::next_pe($pe)
fn::prev_pe_exclude_type($pe, 'ATTA')
fn::next_pe_exclude_type($pe, 'ATTA')

-- 查找特定类型的祖先
fn::find_ancestor_type($pe, 'SPEC')
fn::find_ancestor_types($pe, ['SITE', 'ZONE'])
```

### 5.2 名称和属性函数

```sql
-- 获取默认名称
fn::default_name($pe)
fn::default_names($pes)
fn::default_full_name($pe)

-- 获取祖先属性
fn::ancestor_atts($pe)
```

### 5.3 版本和历史函数

```sql
-- 获取最新版本
fn::newest_pe($pe)
fn::newest_pe_id($pe)

-- 获取指定时间点的版本
fn::latest_pe($pe, $sesno, $dbnum)
fn::find_pe_by_datetime($pe, $datetime)

-- 会话信息
fn::ses_date($pe)
fn::ses_data($pe)
```

### 5.4 递归收集函数

```sql
-- 收集子孙节点 ID
fn::collect_descendant_ids_by_types($pe, $types, $inclusive, $range_str)

-- 收集子孙节点信息
fn::collect_descendant_infos($root, $types, $inclusive, $range_str)

-- 收集有 inst_relate 的子孙节点
fn::collect_descendant_ids_has_inst($root, $types, $inclusive)

-- 收集并过滤 inst/tubi 关系的子孙节点
fn::collect_descendants_filter_inst($root, $types, $filter, $include_self, $skip_deleted)

-- 收集有 CATR/SPRE 属性的子孙节点
fn::collect_descendants_filter_spre($root, $types, $filter_inst, $inclusive, $range_str)

-- 可见几何子孙节点
fn::visible_geo_descendants($root, $include_self, $range_str)

-- 负实体几何子孙节点
fn::negative_geo_descendants($root, $include_self, $range_str)
```

### 5.5 管道连接函数

```sql
-- 查询直段关系
fn::query_tubi_to($pe)      -- 从当前节点出发的直段
fn::query_tubi_from($pe)    -- 到达当前节点的直段
fn::query_bran_first_tubi($pe)

-- 连接节点导航
fn::prev_connect_pe($pe)
fn::next_connect_pe($pe)
fn::prev_connect_pe_data($pe)
fn::next_connect_pe_data($pe)
```

---

## 7. RELATE 关系语句

### 6.1 基本语法

```sql
-- 创建关系记录
RELATE $in->relation_table:[$key1, $key2]->$out
SET field1 = value1, field2 = value2;
```

### 6.2 tubi_relate（直段关系）示例

```rust
let sql = format!(
    "RELATE {}->tubi_relate:[{}, {}]->{} SET \
        geo = inst_geo:⟨{}⟩, \
        aabb = aabb:⟨{}⟩, \
        world_trans = trans:⟨{}⟩, \
        bore_size = {}, \
        bad = {}, \
        system = {}, \
        dt = fn::ses_date({});",
    leave_refno.to_pe_key(),      // in: 离开点
    branch_refno.to_pe_key(),     // 关系 ID 部分 1
    tubing_index,                  // 关系 ID 部分 2
    arrive_refno.to_pe_key(),     // out: 到达点
    geo_hash,
    aabb_hash,
    trans_hash,
    bore_size,
    bad_flag,
    system_refno.to_pe_key(),
    leave_refno.to_pe_key(),
);
```

### 6.3 inst_relate（实例关系）

```sql
-- 创建实例关系
RELATE $pe->inst_relate:[$pe_id]->$inst_geo
SET world_trans = $trans, aabb = $aabb;

-- 查询实例关系
SELECT * FROM $pe->inst_relate;
SELECT VALUE out FROM $pe->inst_relate;
```

### 6.4 pe_owner（父子关系）

```sql
-- 创建父子关系
RELATE $child->pe_owner:[$child, $index]->$parent;

-- 查询子节点
SELECT VALUE in FROM $parent<-pe_owner;

-- 查询父节点
SELECT VALUE out FROM $child->pe_owner;
```

### 6.5 neg_relate / ngmr_relate（负实体关系）

```sql
-- 查询负实体
SELECT VALUE pe FROM $positive_pe<-neg_relate;
SELECT VALUE pe FROM $positive_pe<-ngmr_relate;

-- 使用函数
fn::query_negative_entities($pe)
-- 返回: array::union($pe<-neg_relate.pe, $pe<-ngmr_relate.pe)
```

---
## 8. TreeIndex 快速层级查询

模型生成过程中使用 TreeIndex 作为层级查询的数据源，提供比 SurrealDB 递归查询更快的层级遍历性能。

### 7.1 TreeIndex 概述

**TreeIndex** 是基于 `indextree` 库构建的内存索引，用于加速层级查询：

- **数据源**：从 `output/scene_tree/*.tree` 文件加载（每个 dbnum 一个文件）
- **查询类型**：层级查询（子节点、子孙节点、祖先节点）
- **数据范围**：只用于层级关系，PE/属性仍由 SurrealDB 提供
- **性能优势**：内存查询，比 SurrealDB 递归查询快 10-100 倍

### 7.2 TreeIndex 初始化

```rust
// gen_model-dev 中的自动初始化
// 位置：src/fast_model/query_provider.rs::init_provider()

use crate::fast_model::query_provider::get_model_query_provider;

// 获取查询提供者（自动使用 TreeIndex）
let provider = get_model_query_provider().await?;
// 输出：使用 TreeIndex 查询提供者（层级查询走 indextree）

// 手动初始化（使用大栈线程避免栈溢出）
let handle = std::thread::Builder::new()
    .name("tree-index-loader".to_string())
    .stack_size(64 * 1024 * 1024)  // 64MB 栈
    .spawn(|| TreeIndexQueryProvider::from_tree_dir("output/scene_tree"))?;
let provider = handle.join()??;
```

**初始化注意事项**：
- Windows 上加载大 `.tree` 文件可能触发栈溢出
- 使用大栈线程（64MB）执行初始化，避免 `STATUS_STACK_OVERFLOW`
- 树索引文件路径：`output/scene_tree/{dbnum}.tree`

### 7.3 TreeIndex 查询 API

#### 查询子节点

```rust
use aios_core::collect_children_filter_ids;

// 查询直接子节点（单层）
let children = collect_children_filter_ids(refno, &["EQUI", "PIPE"]).await?;

// 查询所有子节点（不限制类型）
let all_children = collect_children_filter_ids(refno, &[]).await?;
```

#### 查询子孙节点

```rust
use aios_core::collect_descendant_filter_ids;

// 查询所有子孙节点（不限深度）
let descendants = collect_descendant_filter_ids(&[refno], &["EQUI", "PIPE"], None).await?;

// 限制深度（1-5 层）
let shallow = collect_descendant_filter_ids(&[refno], &["EQUI"], Some("1..5")).await?;

// 批量查询多个根节点
let multi_descendants = collect_descendant_filter_ids(
    &[refno1, refno2, refno3],
    &["BOX", "CYLI"],
    None
).await?;
```

#### 查询祖先节点

```rust
use aios_core::query_filter_ancestors;

// 查询祖先中的 ZONE
let zones = query_filter_ancestors(refno, &["ZONE"]).await?;

// 查询祖先中的 SITE 或 ZONE
let sites_or_zones = query_filter_ancestors(refno, &["SITE", "ZONE"]).await?;
```

### 7.4 查询提供者架构

**分层架构**：

```
应用层（gen_model-dev）
  ↓
query_provider::get_model_query_provider()
  ↓
TreeIndexQueryProvider（层级查询）
  ├─ TreeIndex（indextree，内存索引）
  └─ SurrealQueryProvider（PE/属性查询，委托）
      └─ SurrealDB（实际数据库）
```

**查询路由**：

| 查询类型 | 使用提供者 | 数据源 |
|---------|-----------|--------|
| 层级查询（子节点/子孙/祖先） | TreeIndex | `.tree` 文件（内存） |
| PE 查询（get_pe） | SurrealDB | `pe` 表 |
| 属性查询（get_named_attmap） | SurrealDB | `named_attr` 表 |
| 实例查询（inst_relate） | SurrealDB | `inst_relate` 表 |

### 7.5 TreeIndex vs SurrealDB 递归查询

| 场景 | SurrealDB 递归 | TreeIndex | 性能提升 |
|------|---------------|-----------|----------|
| 查询 1000 个节点的子孙（10 层） | ~500ms | ~5ms | **100 倍** |
| 查询单层子节点（100 个） | ~50ms | ~0.5ms | **100 倍** |
| 查询祖先（5 层） | ~30ms | ~0.3ms | **100 倍** |
| 批量查询（10 个根节点） | ~5s | ~50ms | **100 倍** |

**性能优化原理**：
1. **内存索引**：`.tree` 文件反序列化到内存，避免数据库网络往返
2. **BFS 遍历**：使用广度优先搜索，比递归查询更高效
3. **早期过滤**：在索引层面过滤 noun 类型，减少不必要的数据传输

### 7.6 使用示例

```rust
// 查询目标节点的子孙中的 BRAN/HANG
let target_bran_hanger_refnos = query_multi_descendants(
    target_refnos,
    &["BRAN", "HANG"]
).await?;

// 查询可见几何子孙节点
let visible_geos = query_visible_geo_descendants(
    zone_refno,
    false,  // include_self
    None    // range_str
).await?;
```

### 7.7 最佳实践

1. **优先使用 TreeIndex** 进行层级查询
2. **批量查询优于循环查询**
3. **合理限制查询深度**（如 `Some("1..3")`）
4. **使用预定义的 noun 哈希集合**（如 `VISIBLE_GEO_NOUN_HASHES`）

---

## 9. 模型生成相关表查询

本文档详细说明模型生成过程中涉及的数据表查询语法和最佳实践。相关表结构说明请参考 `gen_model-dev/开发文档/模型生成/01_数据表结构与保存流程.md`。

### 8.1 表分类概览

**普通表 (NORMAL)**：
- `inst_geo` - 几何单元表
- `inst_info` - 实例信息表
- `tubi_info` - 管道信息表

**关系表 (RELATION)**：
- `inst_relate` - 实例关系表（pe → inst_info）
- `geo_relate` - 几何关系表（inst_info → inst_geo）
- `inst_relate_aabb` - 实例包围盒关系表（pe → aabb）
- `inst_relate_bool` - 布尔运算关系表
- `inst_relate_cata_bool` - CATE 布尔运算关系表
- `neg_relate` - 负实体关系表（geo_relate → pe）
- `ngmr_relate` - NGMR 负实体关系表（geo_relate → pe）
- `tubi_relate` - 管道关系表（pe → inst_info/tubi_info）

### 8.2 inst_geo 几何单元表查询

```sql
-- 查询单个几何单元
SELECT * FROM inst_geo:⟨{geo_hash}⟩;

-- 查询已网格化的几何单元
SELECT * FROM inst_geo WHERE meshed = true;

-- 查询错误的几何单元
SELECT * FROM inst_geo WHERE bad = true;

-- 批量查询几何单元
SELECT * FROM [inst_geo:⟨hash1⟩, inst_geo:⟨hash2⟩];

-- 查询指定构件编号的几何单元
SELECT * FROM inst_geo WHERE refno = pe:⟨{refno}⟩;
```

### 8.3 inst_info 实例信息表查询

```sql
-- 查询单个实例信息
SELECT * FROM inst_info:⟨{refno}_info⟩;

-- 查询特定类型的实例
SELECT * FROM inst_info WHERE generic_type = 'EQUI';

-- 查询指定 ZONE 的实例
SELECT * FROM inst_info 
WHERE owner_refno IN (
    SELECT VALUE id FROM fn::collect_descendant_ids_by_types(pe:⟨{zone_refno}⟩, ['EQUI'], none, "..")
);

-- 批量查询实例信息
SELECT * FROM [inst_info:⟨refno1_info⟩, inst_info:⟨refno2_info⟩];
```

### 8.4 inst_relate 实例关系表查询

```sql
-- 查询构件的实例关系
SELECT * FROM pe:⟨{refno}⟩->inst_relate;

-- 获取实例信息（通过关系）
SELECT VALUE out FROM pe:⟨{refno}⟩->inst_relate;

-- 查询所有有实例关系的构件
SELECT VALUE in FROM inst_relate;

-- 查询特定类型的实例关系
SELECT * FROM inst_relate WHERE generic = 'EQUI';

-- 查询指定 ZONE 的所有实例关系
SELECT * FROM inst_relate WHERE zone_refno = pe:⟨{zone_refno}⟩;

-- 查询实例关系及其详细信息
SELECT 
    ir.in as refno,
    ir.out as inst_info,
    ir.world_trans,
    ir.generic,
    ir.zone_refno
FROM inst_relate ir
WHERE ir.in = pe:⟨{refno}⟩;
```

### 8.5 geo_relate 几何关系表查询

```sql
-- 查询实例的所有几何关系
SELECT * FROM geo_relate WHERE in = inst_info:⟨{refno}_info⟩;

-- 获取实例的所有几何单元
SELECT VALUE out FROM geo_relate WHERE in = inst_info:⟨{refno}_info⟩;

-- 查询几何关系及其变换信息
SELECT 
    gr.in as inst_info,
    gr.out as inst_geo,
    gr.trans as transform,
    gr.geom_refno,
    gr.geo_type,
    gr.visible
FROM geo_relate gr
WHERE gr.in = inst_info:⟨{refno}_info⟩;

-- 查询特定类型的几何关系（如负实体）
SELECT * FROM geo_relate WHERE geo_type = 'Neg';

-- 查询可见的几何关系
SELECT * FROM geo_relate WHERE visible = true;
```

### 8.6 复合查询：获取构件的完整几何实例信息

```sql
-- 查询构件的所有几何实例（包含变换信息）
SELECT 
    ir.in as refno,
    ir.generic,
    gr.out as geo_hash,
    gr.trans as local_transform,
    gr.geo_type,
    gr.visible,
    ig.meshed,
    ig.bad
FROM pe:⟨{refno}⟩->inst_relate AS ir
INNER JOIN ir.out->geo_relate AS gr
INNER JOIN gr.out AS ig
WHERE gr.visible = true;

-- 使用图遍历语法
SELECT 
    VALUE {
        refno: ->inst_relate.in,
        inst_info: ->inst_relate.out,
        geos: array::map(->inst_relate.out->geo_relate, |$gr| {
            geo_hash: $gr.out,
            transform: $gr.trans,
            geo_type: $gr.geo_type,
            visible: $gr.visible
        })
    }
FROM ONLY pe:⟨{refno}⟩;
```

### 8.7 inst_relate_aabb 包围盒关系表查询

```sql
-- 查询构件的包围盒关系
SELECT * FROM pe:⟨{refno}⟩->inst_relate_aabb;

-- 获取构件的包围盒
SELECT VALUE out FROM pe:⟨{refno}⟩->inst_relate_aabb;

-- 查询包围盒详细信息
SELECT 
    ira.in as refno,
    ira.out as aabb_record
FROM inst_relate_aabb ira
WHERE ira.in = pe:⟨{refno}⟩;

-- 联合查询实例信息和包围盒
SELECT 
    ir.in as refno,
    ir.world_trans,
    ira.out as aabb
FROM inst_relate ir
LEFT JOIN inst_relate_aabb ira ON ir.in = ira.in
WHERE ir.in = pe:⟨{refno}⟩;
```

### 8.8 neg_relate / ngmr_relate 负实体关系查询

```sql
-- 查询被负实体切割的关系
SELECT * FROM neg_relate WHERE out = pe:⟨{target_refno}⟩;

-- 获取负载体（负实体）
SELECT VALUE pe FROM pe:⟨{target_refno}⟩<-neg_relate;

-- 查询 NGMR 切割关系
SELECT * FROM ngmr_relate WHERE out = pe:⟨{target_refno}⟩;

-- 联合查询所有负实体关系
SELECT VALUE pe FROM pe:⟨{target_refno}⟩<-neg_relate
UNION
SELECT VALUE pe FROM pe:⟨{target_refno}⟩<-ngmr_relate;

-- 查询负实体几何关系
SELECT 
    nr.out as target_refno,
    nr.pe as neg_carrier,
    nr.in as geo_relate_id,
    gr.geo_type,
    gr.trans as transform
FROM neg_relate nr
INNER JOIN nr.in AS gr
WHERE nr.out = pe:⟨{target_refno}⟩;
```

### 8.9 tubi_relate 管道关系表查询

```sql
-- 查询 BRAN 的管道实例（使用 ID range 查询）
SELECT * FROM tubi_relate:[{bran_first_child_refno}, 0]..[{bran_first_child_refno}, 999999];

-- 查询到达/离开指定节点的管道
SELECT * FROM tubi_relate 
WHERE in = pe:⟨{refno}⟩ OR out = pe:⟨{refno}⟩;

-- 查询管道的几何和变换信息
SELECT 
    tr.id[0] as refno,
    tr.in as leave,
    tr.out as arrive,
    tr.geo as geo_hash,
    tr.world_trans,
    tr.aabb
FROM tubi_relate:[{bran_first_child_refno}, 0]..[{bran_first_child_refno}, 999999] AS tr;

-- 查询 BRAN 的管道实例（使用函数）
SELECT * FROM fn::query_bran_first_tubi(pe:⟨{bran_refno}⟩);

-- 查询从节点出发的管道
SELECT VALUE out FROM fn::query_tubi_to(pe:⟨{refno}⟩);

-- 查询到达节点的管道
SELECT VALUE in FROM fn::query_tubi_from(pe:⟨{refno}⟩);
```

### 8.10 布尔运算关系查询

```sql
-- 查询构件的布尔运算结果
SELECT * FROM inst_relate_bool WHERE in = inst_geo:⟨{geo_hash}⟩;

-- 获取布尔运算后的几何
SELECT VALUE out FROM inst_geo:⟨{geo_hash}⟩->inst_relate_bool;

-- 查询 CATE 布尔运算结果
SELECT * FROM inst_relate_cata_bool WHERE in = inst_info:⟨{refno}_info⟩;

-- 查询布尔运算成功的实例（用于导出）
SELECT 
    gr.out as original_geo,
    COALESCE(br.out, gr.out) as final_geo,  -- 优先使用布尔结果
    br.status as bool_status
FROM inst_info:⟨{refno}_info⟩->geo_relate AS gr
LEFT JOIN gr.out->inst_relate_bool AS br
WHERE br.status = 'Success' OR br.status = NONE;
```

### 8.11 批量查询多个构件的几何实例

```sql
-- 批量查询多个构件的实例关系
SELECT * FROM [
    pe:⟨refno1}⟩->inst_relate,
    pe:⟨refno2}⟩->inst_relate,
    pe:⟨refno3}⟩->inst_relate
];

-- 使用函数批量收集并查询
LET $refnos = fn::collect_descendant_ids_by_types(pe:⟨{root_refno}⟩, ['EQUI', 'PIPE'], none, "..");
SELECT 
    ir.in as refno,
    ir.generic,
    array::map(ir.out->geo_relate, |$gr| $gr.out) as geo_hashes
FROM inst_relate ir
WHERE ir.in IN $refnos;
```

### 8.12 Rust API 查询示例

```rust
use aios_core::{SUL_DB, SurrealQueryExt, RefnoEnum};

// 查询构件的实例信息
let sql = format!(
    "SELECT * FROM pe:{}->inst_relate",
    refno.to_pe_key()
);
let inst_relate: Vec<InstRelateQuery> = SUL_DB.query_take(&sql, 0).await?;

// 查询构件的所有几何单元
let sql = format!(
    r#"
    SELECT VALUE gr.out
    FROM pe:{}->inst_relate.out->geo_relate AS gr
    WHERE gr.visible = true
    "#,
    refno.to_pe_key()
);
let geo_hashes: Vec<String> = SUL_DB.query_take(&sql, 0).await?;

// 查询构件的包围盒
let sql = format!(
    "SELECT VALUE out FROM pe:{}->inst_relate_aabb",
    refno.to_pe_key()
);
let aabb: Option<AabbRecord> = SUL_DB.query_take(&sql, 0).await?;

// 查询 BRAN 的管道实例
let sql = format!(
    "SELECT * FROM tubi_relate:[{}, 0]..[{}, 999999]",
    first_child_refno.to_pe_key(),
    first_child_refno.to_pe_key()
);
let tubi_insts: Vec<TubiInstQuery> = SUL_DB.query_take(&sql, 0).await?;

// 查询负实体关系
let sql = format!(
    "SELECT VALUE pe FROM pe:{}<-neg_relate",
    target_refno.to_pe_key()
);
let neg_carriers: Vec<RefnoEnum> = SUL_DB.query_take(&sql, 0).await?;
```

### 8.13 查询性能优化建议

1. **使用关系遍历替代 JOIN**：
   ```sql
   -- 推荐：使用图遍历语法
   SELECT * FROM pe:⟨refno}⟩->inst_relate.out->geo_relate;
   
   -- 不推荐：使用 JOIN
   SELECT * FROM inst_relate ir
   INNER JOIN geo_relate gr ON ir.out = gr.in
   WHERE ir.in = pe:⟨refno}⟩;
   ```

2. **批量查询优于循环查询**：
   ```rust
   // 推荐：批量查询
   let refnos = vec![refno1, refno2, refno3];
   let pe_keys: Vec<String> = refnos.iter().map(|r| r.to_pe_key()).collect();
   let sql = format!("SELECT * FROM [{}]->inst_relate", pe_keys.join(", "));
   
   // 不推荐：循环查询
   for refno in &refnos {
       let sql = format!("SELECT * FROM {}->inst_relate", refno.to_pe_key());
       // ...
   }
   ```

3. **使用索引字段过滤**：
   ```sql
   -- 使用 zone_refno 索引
   SELECT * FROM inst_relate WHERE zone_refno = pe:⟨{zone_refno}⟩;
   
   -- 使用 in/out 索引
   SELECT * FROM inst_relate WHERE in = pe:⟨{refno}⟩;
   ```

4. **限制查询结果数量**：
   ```sql
   -- 仅查询需要的字段
   SELECT VALUE out FROM pe:⟨refno}⟩->inst_relate;
   
   -- 使用 LIMIT 限制结果
   SELECT * FROM inst_relate WHERE generic = 'EQUI' LIMIT 100;
   ```

### 8.14 常见查询场景

**场景 1：导出构件的完整几何信息**
```sql
SELECT {
    refno: ir.in,
    world_transform: ir.world_trans,
    aabb: ira.out,
    geos: array::map(
        ir.out->geo_relate[WHERE visible = true],
        |$gr| {
            geo_hash: $gr.out,
            local_transform: $gr.trans,
            geo_type: $gr.geo_type
        }
    )
}
FROM pe:⟨{refno}⟩->inst_relate AS ir
LEFT JOIN ir.in->inst_relate_aabb AS ira;
```

**场景 2：查询区域内的所有可见几何**
```sql
LET $zone_refnos = fn::collect_descendant_ids_by_types(pe:⟨{site_refno}⟩, ['ZONE'], none, "..");
SELECT 
    ir.in as refno,
    gr.out as geo_hash,
    gr.trans as transform
FROM inst_relate ir
INNER JOIN ir.out->geo_relate AS gr
WHERE ir.zone_refno IN $zone_refnos
  AND gr.visible = true;
```

**场景 3：查询负实体切割关系**
```sql
SELECT {
    target: nr.out,
    neg_carrier: nr.pe,
    cutting_geo: nr.in->geo_relate.out,
    transform: nr.in->geo_relate.trans
}
FROM neg_relate nr
WHERE nr.out = pe:⟨{target_refno}⟩;
```

---

## 10. 批量查询优化

### 9.1 array::map 批量处理

```sql
-- 对多个起始节点批量执行函数
array::map([$refno1, $refno2, $refno3], |$refno|
    fn::collect_descendant_ids_by_types($refno, ['BOX'], none, "..")
)
```

### 9.2 array::flatten + array::distinct 去重

```sql
-- 完整的批量查询模式
array::distinct(
    array::filter(
        array::flatten(
            array::map([pe:⟨1⟩, pe:⟨2⟩], |$refno|
                fn::collect_descendant_ids_by_types($refno, ['BOX'], none, "..")
            )
        ),
        |$v| $v != none
    )
)
```

### 9.3 LET 变量 + SELECT 组合

```sql
-- 先收集 ID，再查询详情
let $ids = array::distinct(array::filter(array::flatten(array::map([$refno1, $refno2], |$refno|
    fn::collect_descendant_ids_by_types($refno, ['EQUI'], none, "..")
)), |$v| $v != none));

SELECT * FROM $ids;
```

### 9.4 分块处理大数据量

```rust
// 对于大量数据，分块处理避免内存溢出
for chunk in candidates.chunks(500) {
    let pe_keys = chunk.iter().map(|x| x.to_pe_key()).join(",");
    let sql = format!("SELECT VALUE id FROM [{}] WHERE condition;", pe_keys);
    // ...
}
```

---

## 11. Rust API 封装

### 10.1 核心查询 API

| 函数 | 说明 | SELECT 表达式 |
|------|------|---------------|
| `collect_descendant_filter_ids` | 查询子孙节点 ID | `VALUE id` |
| `collect_descendant_elements` | 查询子孙节点完整元素 | `*` |
| `collect_descendant_full_attrs` | 查询子孙节点属性 | `VALUE id.refno.*` |
| `collect_children_filter_ids` | 查询直接子节点 ID | `VALUE id` |
| `collect_children_elements` | 查询直接子节点元素 | `*` |
| `collect_children_filter_attrs` | 查询直接子节点属性 | `VALUE id.refno.*` |

### 10.2 特殊查询 API

```rust
// 查询可见几何子孙
query_visible_geo_descendants(refno, include_self, range_str).await?

// 查询负实体几何子孙
query_negative_geo_descendants(refno, include_self, range_str).await?

// 查询有 inst_relate 的子孙
collect_descendant_ids_has_inst(&refnos, &types, include_self, range_str).await?

// 查询有 CATR/SPRE 的子孙
query_deep_children_refnos_filter_spre(&refnos, filter).await?

// 查询并过滤 inst/tubi 关系
query_deep_children_filter_inst(&refnos, &nouns, filter).await?
```

### 10.3 图遍历 API

```rust
// 按路径查询单个值
query_single_by_paths(refno, &["->GMRE", "->GSTR"], &["REFNO"]).await?

// 查询祖先节点
query_ancestor_refnos(refno).await?
query_filter_ancestors(refno, &["SITE", "ZONE"]).await?

// 查询属性
get_named_attmap(refno).await?
get_world_transform(refno).await?
get_type_name(refno).await?
get_cat_refno(ele_refno).await?

// 查询子节点
get_children_pes(refno).await?
```

---

## 12. 性能优化最佳实践

### 11.1 使用数据库端函数

**推荐**：将逻辑移到数据库端执行
```sql
-- 好：一次数据库调用完成所有操作
fn::collect_descendants_filter_inst($root, ['BOX'], true, true, false)

-- 差：多次网络往返
-- 1. 先查询所有子孙
-- 2. 再分批过滤
```

### 11.2 批量处理多个起点

```rust
// 好：批量处理
let children = collect_descendant_filter_ids(&[refno1, refno2, refno3], &["BOX"], None).await?;

// 差：串行循环
for refno in &refnos {
    let children = collect_descendant_filter_ids(&[*refno], &["BOX"], None).await?;
}
```

### 11.3 限制递归深度

```rust
// 如果只需要前几层，指定范围
collect_descendant_filter_ids(&[refno], &["BOX"], Some("1..3")).await?
```

### 11.4 使用 COUNT(...LIMIT 1) 检查存在性

```sql
-- 好：快速检查是否存在
WHERE count(SELECT VALUE id FROM ->inst_relate LIMIT 1) = 0

-- 差：获取所有再判断
WHERE array::len(->inst_relate) = 0
```

### 11.5 性能对比数据

| 场景 | 旧实现 | 新实现 | 提升 |
|------|--------|--------|------|
| 2000 节点递归查询 | ~55ms (1次收集 + 10次分块) | ~5ms (1次数据库端处理) | 91% |
| 批量查询多个起点 | 串行 N 次 | 并行 1 次 | N 倍 |

---

## 附录：可见几何类型列表

### 正实体类型（visible_types）
```
BOX, CYLI, SLCY, CONE, DISH, CTOR, RTOR, PYRA, SNOU, POHE, POLYHE,
EXTR, REVO, FLOOR, PANE, ELCONN, CMPF, WALL, GWALL, SJOI, FITT, PFIT,
FIXING, PJOI, GENSEC, RNODE, PRTELE, GPART, SCREED, PALJ, CABLE, BATT,
CMFI, SCOJ, SEVE, SBFI, STWALL, SCTN, NOZZ
```

### 负实体类型（negative_types）
```
NBOX, NCYL, NLCY, NSBO, NCON, NSNO, NPYR, NDIS, NXTR, NCTO, NRTO, NREV,
NSCY, NSCO, NLSN, NSSP, NSCT, NSRT, NSDS, NSSL, NLPY, NSEX, NSRE
```

---

## 参考文件

### 架构文档
- **数据库架构文档**: `rs-core/数据库架构文档.md` - 完整的数据库架构说明
- **表结构详细说明**: `rs-core/docs/数据库查询总结/数据库架构.md` - 表结构详细说明
- **模型生成表结构文档**: `gen_model-dev/开发文档/模型生成/01_数据表结构与保存流程.md`

### 核心代码
- **数据库函数定义**: `rs-core/resource/surreal/common.surql`
- **表结构定义**: `rs-core/src/rs_surreal/inst.rs::init_model_tables()`
- **图查询实现**: `rs-core/src/rs_surreal/graph.rs`
- **PE 查询**: `rs-core/src/rs_surreal/query.rs`
- **实例查询**: `rs-core/src/rs_surreal/inst.rs`
- **查询扩展**: `rs-core/src/rs_surreal/query_ext.rs`

### 查询提供者
- **SurrealDB 查询提供者**: `rs-core/src/query_provider/surreal_provider.rs`
- **TreeIndex 查询提供者**: `rs-core/src/query_provider/tree_index_provider.rs`
- **TreeIndex 查询兼容层**: `gen_model-dev/src/fast_model/query_compat.rs`
- **TreeIndex 查询入口**: `gen_model-dev/src/fast_model/query_provider.rs`

### 配置文件
- **配置文件**: `rs-plant3-d/assets/config/e3d.project.ron`


