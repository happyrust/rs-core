# SurrealDB 数据库查询总结

本文档总结了 rs-plant3d 项目中 SurrealDB 数据库的查询语法和使用模式。

---

## 目录

1. [基础查询语法](#1-基础查询语法)
2. [Record ID 格式](#2-record-id-格式)
3. [图遍历语法](#3-图遍历语法)
4. [递归路径查询](#4-递归路径查询)
5. [数据库端函数](#5-数据库端函数)
6. [RELATE 关系语句](#6-relate-关系语句)
7. [批量查询优化](#7-批量查询优化)
8. [Rust API 封装](#8-rust-api-封装)
9. [性能优化最佳实践](#9-性能优化最佳实践)

---

## 1. 基础查询语法

### 1.1 执行查询

```rust
// 通过全局连接执行查询
let mut response = SUL_DB.query_response(&sql).await?;
let result = response.take::<Vec<T>>(0)?;

// 简化版本
let result: Vec<T> = SUL_DB.query_take(&sql, 0).await?;
```

### 1.2 SELECT 语句

```sql
-- 基础 SELECT
SELECT * FROM pe WHERE noun = 'BOX';

-- 选择特定字段
SELECT refno, name, noun FROM pe WHERE deleted = false;

-- 使用 VALUE 返回单列
SELECT VALUE id FROM pe WHERE noun IN ['BOX', 'CYLI'];

-- 从记录数组查询
SELECT * FROM [pe:⟨123⟩, pe:⟨456⟩];

-- ONLY 限定单条记录
SELECT * FROM ONLY pe:⟨123⟩ LIMIT 1;
```

### 1.3 条件过滤

```sql
-- WHERE 条件
SELECT * FROM pe WHERE noun = 'BRAN' AND deleted = false;

-- IN 操作符
SELECT * FROM pe WHERE noun IN ['BOX', 'CYLI', 'CONE'];

-- 范围查询
SELECT * FROM pe WHERE sesno >= 100 AND sesno <= 200;

-- 嵌套属性访问
SELECT * FROM pe WHERE refno.TYPE = 'EQUI' OR refno.TYPEX = 'EQUI';
```

---

## 2. Record ID 格式

### 2.1 标准格式

```sql
-- 使用尖括号包裹 ID
pe:⟨12345_67890⟩
inst_geo:⟨abc123hash⟩
aabb:⟨xyz789hash⟩
trans:⟨transform_hash⟩

-- 复合 ID（用于历史版本）
pe:⟨["12345_67890", 880]⟩
```

### 2.2 Rust 转换

```rust
// RefnoEnum 转 PE key
let pe_key = refno.to_pe_key();  // 返回 "pe:⟨12345_67890⟩"

// 原始 ID
let raw_id = record_id.to_raw();
```

### 2.3 动态构建 Record ID

```sql
-- 使用 type::record 函数
let $pe_id = type::record('pe', '12345_67890');
let $old_pe_id = type::record('pe', [$id, $sesno]);

-- 使用 record::id 获取 ID 部分
let $id_part = record::id($pe);
```

---

## 3. 图遍历语法

### 3.1 正向遍历（->）

```sql
-- 遍历单个关系
SELECT * FROM pe:⟨123⟩->inst_relate;

-- 链式遍历
SELECT * FROM pe:⟨123⟩->LSTU->CATR;

-- 获取关系终点
SELECT VALUE out FROM pe:⟨123⟩->tubi_relate;
```

### 3.2 反向遍历（<-）

```sql
-- 获取指向当前节点的关系
SELECT * FROM pe:⟨123⟩<-pe_owner;

-- 获取父节点
SELECT VALUE in FROM pe:⟨123⟩->pe_owner;

-- 获取所有子节点
SELECT VALUE in FROM pe:⟨123⟩<-pe_owner;
```

### 3.3 条件过滤遍历

```sql
-- 过滤已删除的节点
SELECT * FROM pe:⟨123⟩<-pe_owner[? !in.deleted];

-- 按类型过滤
SELECT VALUE in FROM pe:⟨123⟩<-pe_owner WHERE in.noun = 'BOX';

-- 复合条件
SELECT VALUE in FROM pe:⟨123⟩<-pe_owner
WHERE in.noun != 'ATTA' AND in.deleted != true;
```

### 3.4 Rust API 调用

```rust
// 使用 query_single_by_paths 遍历图
let result = aios_core::query_single_by_paths(
    cata_refno,
    &["->GMRE", "->GSTR"],  // 遍历路径
    &["REFNO"],             // 要获取的字段
).await?;

// 链式遍历示例
let catr = aios_core::query_single_by_paths(
    leave_refno,
    &["->LSTU->CATR"],
    &["REFNO"],
).await?;
```

---

## 4. 递归路径查询（Recursive Path）

SurrealDB 提供了强大的递归路径查询语法，用于遍历图结构中的层级关系。

### 4.1 递归路径基础语法

递归路径使用 `{range+options}` 格式，放在字段访问表达式中：

```sql
-- 基本格式
@.{range+option1+option2}.field

-- @ 代表当前记录
-- range 指定递归深度范围
-- options 控制递归行为
-- field 是要递归访问的字段名
```

### 4.2 递归范围（Range）语法

| 格式 | 说明 | 示例 SQL |
|------|------|----------|
| `..` | 无限递归（默认） | `@.{..}.children` |
| `3` | 精确 N 层 | `@.{3}.children` |
| `1..5` | 从第 1 层到第 5 层 | `@.{1..5}.children` |
| `..5` | 从第 0 层到第 5 层 | `@.{..5}.children` |
| `3..` | 从第 3 层到无限 | `@.{3..}.children` |

### 4.3 递归选项（Options）

| 选项 | 说明 |
|------|------|
| `collect` | 收集所有层级的结果到数组中 |
| `inclusive` | 包含起始节点本身 |

**组合使用：**

```sql
-- 收集所有子孙（不包含根节点）
@.{..+collect}.children

-- 收集所有子孙（包含根节点）
@.{..+collect+inclusive}.children

-- 收集 1-5 层的子孙
@.{1..5+collect}.children
```

### 4.4 完整递归查询示例

#### 示例 1：获取所有子孙节点

```sql
-- 从根节点递归获取所有 children 字段，展平为数组
SELECT VALUE array::flatten(@.{..+collect}.children)
FROM ONLY pe:⟨12345⟩ LIMIT 1;
```

**执行过程：**

1. 从 `pe:⟨12345⟩` 开始
2. 递归访问每个节点的 `children` 字段
3. `collect` 将每层结果收集到数组
4. `array::flatten` 将嵌套数组展平

#### 示例 2：获取子孙节点的特定字段

```sql
-- 获取所有子孙的 id 和 noun
SELECT VALUE array::flatten(@.{..+collect+inclusive}.children).{ id, noun }
FROM ONLY $root LIMIT 1;
```

**返回结构：**

```json
[
  { "id": "pe:⟨100⟩", "noun": "BOX" },
  { "id": "pe:⟨101⟩", "noun": "CYLI" },
  { "id": "pe:⟨102⟩", "noun": "CONE" }
]
```

#### 示例 3：获取祖先链

```sql
-- 使用 owner 字段向上递归获取祖先
SELECT VALUE @.{..+collect+inclusive}.owner
FROM ONLY pe:⟨12345⟩ LIMIT 1;
```

### 4.5 与 pe_owner 关系表的区别

项目中有两种获取层级关系的方式：

#### 方式 1：通过 children 字段递归（推荐）

```sql
-- pe 表中存储了 children 数组字段
SELECT VALUE array::flatten(@.{..+collect}.children) FROM ONLY $root;
```

#### 方式 2：通过 pe_owner 关系表反向遍历

```sql
-- 获取所有指向 $root 的 pe_owner 关系的 in 端
SELECT VALUE in FROM $root<-pe_owner;
```

#### 对比

| 特性 | children 递归 | pe_owner 关系 |
|------|---------------|---------------|
| 性能 | 单次查询完成 | 需要多次遍历 |
| 深度控制 | 支持 range 语法 | 需要手动控制 |
| 数据一致性 | 依赖 children 字段 | 依赖关系表 |
| 适用场景 | 批量获取子孙 | 单层父子查询 |

### 4.6 递归范围字符串（range_str）参数

在 Rust API 中，`range_str` 参数用于动态控制递归深度：

| 参数值 | 说明 | 生成的 SQL |
|--------|------|------------|
| `None` | 无限递归（默认 ".."） | `@.{..+collect}` |
| `Some("..")` | 无限递归 | `@.{..+collect}` |
| `Some("3")` | 精确 3 层 | `@.{3+collect}` |
| `Some("1..5")` | 1 到 5 层 | `@.{1..5+collect}` |
| `Some("..5")` | 最多 5 层 | `@.{..5+collect}` |

### 4.7 核心递归语法总结

```sql
-- 标准递归收集模板
SELECT VALUE array::flatten(@.{RANGE+collect+OPTIONS}.FIELD).{ PROJECTIONS }
FROM ONLY $root LIMIT 1;

-- 其中：
-- RANGE: .., 3, 1..5, ..5 等
-- OPTIONS: inclusive（可选）
-- FIELD: children, owner 等递归字段
-- PROJECTIONS: id, noun, refno.* 等投影字段
```

### 4.8 fn::collect_descendant_ids_by_types

这是项目中最核心的递归查询函数：

```sql
-- 函数定义
DEFINE FUNCTION fn::collect_descendant_ids_by_types(
    $pe: record,           -- 起始节点
    $t: array,             -- 类型过滤数组
    $inclusive: option<bool>,  -- 是否包含根节点
    $range_str: string     -- 递归范围
) {
    let $infos = fn::collect_descendant_infos($pe, $t, $inclusive, $range_str);
    return array::map($infos, |$info| $info.id);
};
```

**内部实现（fn::collect_descendant_infos）：**

```sql
DEFINE FUNCTION fn::collect_descendant_infos(
    $root: record,
    $types: array<string>,
    $inclusive: option<bool>,
    $range_str: string,
) {
    if !record::exists($root) {
        return [];
    };

    let $use_inclusive = $inclusive ?: true;

    -- 核心递归查询语句
    let $raw_descendants = if $use_inclusive {
        (SELECT VALUE array::flatten(@.{..+collect+inclusive}.children).{ id, noun }
         FROM ONLY $root LIMIT 1) ?: []
    } else {
        (SELECT VALUE array::flatten(@.{..+collect}.children).{ id, noun }
         FROM ONLY $root LIMIT 1) ?: []
    };

    -- 类型过滤
    let $filtered = array::filter($raw_descendants, |$node|
        $node != NONE
        && $node.id != NONE
        && (array::len($types) == 0 || $node.noun IN $types)
    );

    return $filtered;
};
```

### 4.4 Rust 端调用模式

```rust
/// collect_descendant_with_expr - 泛型递归查询函数
pub async fn collect_descendant_with_expr<T: SurrealValue>(
    refnos: &[RefnoEnum],
    nouns: &[&str],
    range_str: Option<&str>,
    select_expr: &str,
) -> anyhow::Result<Vec<T>> {
    let nouns_str = rs_surreal::convert_to_sql_str_array(nouns);
    let types_expr = if nouns.is_empty() {
        "[]".to_string()
    } else {
        format!("[{}]", nouns_str)
    };

    let refno_keys: Vec<String> = refnos.iter().map(|r| r.to_pe_key()).collect();
    let refno_list = refno_keys.join(", ");
    let range = range_str.unwrap_or("..");

    // 生成的 SQL：
    let sql = format!(
        r#"
        let $ids = array::distinct(array::filter(array::flatten(array::map([{}], |$refno|
            fn::collect_descendant_ids_by_types($refno, {}, none, "{}")
        )), |$v| $v != none));
        SELECT {} FROM $ids;
        "#,
        refno_list, types_expr, range, select_expr
    );

    let result: Vec<T> = SUL_DB.query_take(&sql, 1).await?;
    Ok(result)
}
```

### 4.5 常用递归查询 API

```rust
// 查询深度子孙节点 ID
collect_descendant_filter_ids(&[refno], &["BOX", "CYLI"], None).await?;
collect_descendant_filter_ids(&[refno], &["BOX", "CYLI"], Some("1..5")).await?;

// 查询深度子孙节点完整元素
collect_descendant_elements(&[refno], &["EQUI"], None).await?;

// 查询深度子孙节点属性
collect_descendant_full_attrs(&[refno], &["ZONE"], Some("1..3")).await?;

// 查询可见几何子孙节点
query_visible_geo_descendants(refno, false, None).await?;

// 查询负实体几何子孙节点
query_negative_geo_descendants(refno, false, Some("1..3")).await?;

// 查询直接子节点（单层）
collect_children_filter_ids(refno, &["EQUI", "PIPE"]).await?;

// 查询祖先节点
query_filter_ancestors(refno, &["SITE", "ZONE"]).await?;
```

---

## 5. 数据库端函数

### 5.1 节点导航函数

```sql
-- 获取祖先节点
fn::ancestor($pe)

-- 获取子节点
fn::children($pe)
fn::first_child($pe)
fn::last_child($pe)
fn::collect_children($root, $types)

-- 获取兄弟节点
fn::prev_pe($pe)
fn::next_pe($pe)
fn::prev_pe_exclude_type($pe, 'ATTA')
fn::next_pe_exclude_type($pe, 'ATTA')

-- 查找特定类型的祖先
fn::find_ancestor_type($pe, 'SPEC')
fn::find_ancestor_types($pe, ['SITE', 'ZONE'])
```

### 5.2 名称和属性函数

```sql
-- 获取默认名称
fn::default_name($pe)
fn::default_names($pes)
fn::default_full_name($pe)

-- 获取祖先属性
fn::ancestor_atts($pe)
```

### 5.3 版本和历史函数

```sql
-- 获取最新版本
fn::newest_pe($pe)
fn::newest_pe_id($pe)

-- 获取指定时间点的版本
fn::latest_pe($pe, $sesno, $dbnum)
fn::find_pe_by_datetime($pe, $datetime)

-- 会话信息
fn::ses_date($pe)
fn::ses_data($pe)
```

### 5.4 递归收集函数

```sql
-- 收集子孙节点 ID
fn::collect_descendant_ids_by_types($pe, $types, $inclusive, $range_str)

-- 收集子孙节点信息
fn::collect_descendant_infos($root, $types, $inclusive, $range_str)

-- 收集有 inst_relate 的子孙节点
fn::collect_descendant_ids_has_inst($root, $types, $inclusive)

-- 收集并过滤 inst/tubi 关系的子孙节点
fn::collect_descendants_filter_inst($root, $types, $filter, $include_self, $skip_deleted)

-- 收集有 CATR/SPRE 属性的子孙节点
fn::collect_descendants_filter_spre($root, $types, $filter_inst, $inclusive, $range_str)

-- 可见几何子孙节点
fn::visible_geo_descendants($root, $include_self, $range_str)

-- 负实体几何子孙节点
fn::negative_geo_descendants($root, $include_self, $range_str)
```

### 5.5 管道连接函数

```sql
-- 查询直段关系
fn::query_tubi_to($pe)      -- 从当前节点出发的直段
fn::query_tubi_from($pe)    -- 到达当前节点的直段
fn::query_bran_first_tubi($pe)

-- 连接节点导航
fn::prev_connect_pe($pe)
fn::next_connect_pe($pe)
fn::prev_connect_pe_data($pe)
fn::next_connect_pe_data($pe)
```

---

## 6. RELATE 关系语句

### 6.1 基本语法

```sql
-- 创建关系记录
RELATE $in->relation_table:[$key1, $key2]->$out
SET field1 = value1, field2 = value2;
```

### 6.2 tubi_relate（直段关系）示例

```rust
let sql = format!(
    "RELATE {}->tubi_relate:[{}, {}]->{} SET \
        geo = inst_geo:⟨{}⟩, \
        aabb = aabb:⟨{}⟩, \
        world_trans = trans:⟨{}⟩, \
        bore_size = {}, \
        bad = {}, \
        system = {}, \
        dt = fn::ses_date({});",
    leave_refno.to_pe_key(),      // in: 离开点
    branch_refno.to_pe_key(),     // 关系 ID 部分 1
    tubing_index,                  // 关系 ID 部分 2
    arrive_refno.to_pe_key(),     // out: 到达点
    geo_hash,
    aabb_hash,
    trans_hash,
    bore_size,
    bad_flag,
    system_refno.to_pe_key(),
    leave_refno.to_pe_key(),
);
```

### 6.3 inst_relate（实例关系）

```sql
-- 创建实例关系
RELATE $pe->inst_relate:[$pe_id]->$inst_geo
SET world_trans = $trans, aabb = $aabb;

-- 查询实例关系
SELECT * FROM $pe->inst_relate;
SELECT VALUE out FROM $pe->inst_relate;
```

### 6.4 pe_owner（父子关系）

```sql
-- 创建父子关系
RELATE $child->pe_owner:[$child, $index]->$parent;

-- 查询子节点
SELECT VALUE in FROM $parent<-pe_owner;

-- 查询父节点
SELECT VALUE out FROM $child->pe_owner;
```

### 6.5 neg_relate / ngmr_relate（负实体关系）

```sql
-- 查询负实体
SELECT VALUE pe FROM $positive_pe<-neg_relate;
SELECT VALUE pe FROM $positive_pe<-ngmr_relate;

-- 使用函数
fn::query_negative_entities($pe)
-- 返回: array::union($pe<-neg_relate.pe, $pe<-ngmr_relate.pe)
```

---

## 7. 批量查询优化

### 7.1 array::map 批量处理

```sql
-- 对多个起始节点批量执行函数
array::map([$refno1, $refno2, $refno3], |$refno|
    fn::collect_descendant_ids_by_types($refno, ['BOX'], none, "..")
)
```

### 7.2 array::flatten + array::distinct 去重

```sql
-- 完整的批量查询模式
array::distinct(
    array::filter(
        array::flatten(
            array::map([pe:⟨1⟩, pe:⟨2⟩], |$refno|
                fn::collect_descendant_ids_by_types($refno, ['BOX'], none, "..")
            )
        ),
        |$v| $v != none
    )
)
```

### 7.3 LET 变量 + SELECT 组合

```sql
-- 先收集 ID，再查询详情
let $ids = array::distinct(array::filter(array::flatten(array::map([$refno1, $refno2], |$refno|
    fn::collect_descendant_ids_by_types($refno, ['EQUI'], none, "..")
)), |$v| $v != none));

SELECT * FROM $ids;
```

### 7.4 分块处理大数据量

```rust
// 对于大量数据，分块处理避免内存溢出
for chunk in candidates.chunks(500) {
    let pe_keys = chunk.iter().map(|x| x.to_pe_key()).join(",");
    let sql = format!("SELECT VALUE id FROM [{}] WHERE condition;", pe_keys);
    // ...
}
```

---

## 8. Rust API 封装

### 8.1 核心查询 API

| 函数 | 说明 | SELECT 表达式 |
|------|------|---------------|
| `collect_descendant_filter_ids` | 查询子孙节点 ID | `VALUE id` |
| `collect_descendant_elements` | 查询子孙节点完整元素 | `*` |
| `collect_descendant_full_attrs` | 查询子孙节点属性 | `VALUE id.refno.*` |
| `collect_children_filter_ids` | 查询直接子节点 ID | `VALUE id` |
| `collect_children_elements` | 查询直接子节点元素 | `*` |
| `collect_children_filter_attrs` | 查询直接子节点属性 | `VALUE id.refno.*` |

### 8.2 特殊查询 API

```rust
// 查询可见几何子孙
query_visible_geo_descendants(refno, include_self, range_str).await?

// 查询负实体几何子孙
query_negative_geo_descendants(refno, include_self, range_str).await?

// 查询有 inst_relate 的子孙
collect_descendant_ids_has_inst(&refnos, &types, include_self, range_str).await?

// 查询有 CATR/SPRE 的子孙
query_deep_children_refnos_filter_spre(&refnos, filter).await?

// 查询并过滤 inst/tubi 关系
query_deep_children_filter_inst(&refnos, &nouns, filter).await?
```

### 8.3 图遍历 API

```rust
// 按路径查询单个值
query_single_by_paths(refno, &["->GMRE", "->GSTR"], &["REFNO"]).await?

// 查询祖先节点
query_ancestor_refnos(refno).await?
query_filter_ancestors(refno, &["SITE", "ZONE"]).await?

// 查询属性
get_named_attmap(refno).await?
get_world_transform(refno).await?
get_type_name(refno).await?
get_cat_refno(ele_refno).await?

// 查询子节点
get_children_pes(refno).await?
```

---

## 9. 性能优化最佳实践

### 9.1 使用数据库端函数

**推荐**：将逻辑移到数据库端执行
```sql
-- 好：一次数据库调用完成所有操作
fn::collect_descendants_filter_inst($root, ['BOX'], true, true, false)

-- 差：多次网络往返
-- 1. 先查询所有子孙
-- 2. 再分批过滤
```

### 9.2 批量处理多个起点

```rust
// 好：批量处理
let children = collect_descendant_filter_ids(&[refno1, refno2, refno3], &["BOX"], None).await?;

// 差：串行循环
for refno in &refnos {
    let children = collect_descendant_filter_ids(&[*refno], &["BOX"], None).await?;
}
```

### 9.3 限制递归深度

```rust
// 如果只需要前几层，指定范围
collect_descendant_filter_ids(&[refno], &["BOX"], Some("1..3")).await?
```

### 9.4 使用 COUNT(...LIMIT 1) 检查存在性

```sql
-- 好：快速检查是否存在
WHERE count(SELECT VALUE id FROM ->inst_relate LIMIT 1) = 0

-- 差：获取所有再判断
WHERE array::len(->inst_relate) = 0
```

### 9.5 性能对比数据

| 场景 | 旧实现 | 新实现 | 提升 |
|------|--------|--------|------|
| 2000 节点递归查询 | ~55ms (1次收集 + 10次分块) | ~5ms (1次数据库端处理) | 91% |
| 批量查询多个起点 | 串行 N 次 | 并行 1 次 | N 倍 |

---

## 附录：可见几何类型列表

### 正实体类型（visible_types）
```
BOX, CYLI, SLCY, CONE, DISH, CTOR, RTOR, PYRA, SNOU, POHE, POLYHE,
EXTR, REVO, FLOOR, PANE, ELCONN, CMPF, WALL, GWALL, SJOI, FITT, PFIT,
FIXING, PJOI, GENSEC, RNODE, PRTELE, GPART, SCREED, PALJ, CABLE, BATT,
CMFI, SCOJ, SEVE, SBFI, STWALL, SCTN, NOZZ
```

### 负实体类型（negative_types）
```
NBOX, NCYL, NLCY, NSBO, NCON, NSNO, NPYR, NDIS, NXTR, NCTO, NRTO, NREV,
NSCY, NSCO, NLSN, NSSP, NSCT, NSRT, NSDS, NSSL, NLPY, NSEX, NSRE
```

---

## 参考文件

- **数据库函数定义**: `rs-core/resource/surreal/common.surql`
- **图查询实现**: `rs-core/src/rs_surreal/graph.rs`
- **查询提供者**: `rs-core/src/query_provider/surreal_provider.rs`
- **配置文件**: `rs-plant3-d/assets/config/e3d.project.ron`
