# 查询优化指南

本文档总结了 aios-core 中 SurrealDB 查询的性能优化策略和最佳实践。

---

## 性能优化策略

### 1. 数据库端处理优先

将复杂逻辑放在数据库端执行，减少网络往返次数。

**性能对比示例**（2000节点场景）：
| 实现方式 | 耗时 | 网络往返 |
|----------|------|----------|
| 旧实现（分块循环） | ~55ms | 11次（1次收集 + 10次过滤） |
| 新实现（数据库端） | ~5ms | 1次 |
| **提升** | **91%** | **91%** |

### 2. 批量查询模式

#### array::map + array::flatten + array::distinct 模式

```sql
-- 批量处理多个起点，在数据库端完成所有操作
array::distinct(
    array::filter(
        array::flatten(
            array::map([pe:⟨a⟩, pe:⟨b⟩, pe:⟨c⟩], |$refno|
                fn::collect_descendants_filter_inst($refno, [], true, true, false)
            )
        ), 
        |$v| $v != none
    )
)
```

**模式解析**：
1. `array::map` - 对每个输入执行相同函数
2. `array::flatten` - 将嵌套数组展平
3. `array::filter` - 过滤无效值
4. `array::distinct` - 去重

---

## 分块处理策略

### 最佳分块大小

对于大量数据的处理，推荐分块大小：

| 场景 | 推荐分块 | 原因 |
|------|----------|------|
| ID 列表查询 | 500 | 平衡内存和网络开销 |
| 实例详情查询 | 50 | 单条记录数据量大 |
| 写入操作 | 100 | 避免事务过大 |

### 分块示例

```rust
pub async fn query_insts_with_batch(
    refnos: impl IntoIterator<Item = &RefnoEnum>,
    enable_holes: bool,
    batch_size: Option<usize>,
) -> anyhow::Result<Vec<GeomInstQuery>> {
    let batch = batch_size.unwrap_or(50).max(1);
    let mut results = Vec::new();
    
    for chunk in refnos.chunks(batch) {
        let inst_keys = get_inst_relate_keys(chunk);
        let sql = format!("SELECT ... FROM {inst_keys} WHERE ...");
        let mut chunk_result: Vec<GeomInstQuery> = SUL_DB.query_take(&sql, 0).await?;
        results.append(&mut chunk_result);
    }
    
    Ok(results)
}
```

---

## 缓存策略

### #[cached] 宏使用

使用 `cached` crate 缓存频繁查询的结果：

```rust
use cached::proc_macro::cached;

// 基本缓存（默认 LRU）
#[cached(result = true)]
pub async fn query_deep_children_refnos(refno: RefnoEnum) -> anyhow::Result<Vec<RefnoEnum>> {
    collect_descendant_filter_ids(&[refno], &[], None).await
}

// 带大小限制的缓存
#[cached(result = true, size = 10000)]
pub async fn get_pe(refno: RefnoEnum) -> anyhow::Result<Option<SPdmsElement>> {
    let sql = format!("SELECT * OMIT id FROM ONLY {} LIMIT 1;", refno.to_pe_key());
    SUL_DB.query_take::<Option<SPdmsElement>>(&sql, 0).await
}

// 自定义缓存键
#[cached(
    result = true,
    size = 5000,
    key = "(RefnoEnum, String)",
    convert = r#"{ (refno, ancestor_type.to_string()) }"#
)]
pub async fn query_ancestor_refno_by_type(
    refno: RefnoEnum,
    ancestor_type: &str,
) -> anyhow::Result<Option<RefnoEnum>> {
    // ...
}
```

### 缓存适用场景

| 场景 | 是否适合缓存 | 原因 |
|------|-------------|------|
| PE 元素查询 | ✅ | 数据变化少，查询频繁 |
| 祖先/子孙查询 | ✅ | 层级关系相对稳定 |
| 实例几何查询 | ⚠️ 谨慎 | 模型生成时可能频繁变化 |
| 统计数量查询 | ❌ | 数据变化频繁 |

---

## ID Range 查询优化

### 性能对比

```sql
-- ❌ 慢：使用 WHERE 条件
SELECT * FROM tubi_relate WHERE record::id(id)[0] = pe:⟨21491_10000⟩;

-- ✅ 快：使用 ID Range（索引查询）
SELECT * FROM tubi_relate:[pe:⟨21491_10000⟩, 0]..[pe:⟨21491_10000⟩, ..];
```

ID Range 利用 SurrealDB 的 B-Tree 索引，直接定位记录范围。

### 适用表

| 表名 | 复合 ID 格式 | Range 查询示例 |
|------|-------------|---------------|
| `tubi_relate` | `[pe_key, index]` | `tubi_relate:[pe:⟨x⟩, 0]..[pe:⟨x⟩, ..]` |
| `neg_relate` | `[neg_refno, index]` | `neg_relate:[pe:⟨x⟩, 0]..[pe:⟨x⟩, ..]` |
| `ngmr_relate` | `[ele_pe, target_pe, ngmr_pe]` | 需按第一个元素构建范围 |

---

## 查询语句优化

### 1. 避免 record::id() 函数

```sql
-- ❌ 慢：额外函数调用
SELECT record::id(id)[0] as refno FROM tubi_relate;

-- ✅ 快：直接访问
SELECT id[0] as refno FROM tubi_relate;
```

### 2. 使用 count() + LIMIT 1 优化

```sql
-- ❌ 慢：遍历所有关系
SELECT * FROM pe:⟨x⟩->inst_relate;
-- 然后在 Rust 中检查 len() > 0

-- ✅ 快：使用 count + LIMIT
SELECT count() FROM pe:⟨x⟩->inst_relate LIMIT 1;
-- 或
count((SELECT 1 FROM pe:⟨x⟩->inst_relate LIMIT 1)) > 0
```

### 3. 使用 ONLY 限定单条结果

```sql
-- ❌ 返回数组，需要取第一个
SELECT * FROM pe:⟨21491_10000⟩ LIMIT 1;

-- ✅ 直接返回单条记录
SELECT * FROM ONLY pe:⟨21491_10000⟩;
```

### 4. 使用 OMIT 排除不需要的字段

```sql
-- ❌ 返回所有字段（包括大字段）
SELECT * FROM pe:⟨21491_10000⟩;

-- ✅ 排除大字段或不需要的字段
SELECT * OMIT id, large_data FROM pe:⟨21491_10000⟩;
```

---

## 连接管理

### 单例模式

项目使用全局单例 `SUL_DB` 管理数据库连接：

```rust
use once_cell::sync::Lazy;
use surrealdb::Surreal;
use surrealdb::engine::any::Any;

pub static SUL_DB: Lazy<Surreal<Any>> = Lazy::new(|| {
    Surreal::init()
});
```

### 连接重试

使用 `ConnectionManager` 处理连接断开和重连：

```rust
use aios_core::rs_surreal::ConnectionManager;

let manager = ConnectionManager::new();
manager.connect_or_reconnect(&SUL_DB, &new_config).await?;
```

---

## 错误处理

### 使用 #[track_caller] 追踪查询位置

```rust
#[track_caller]
pub async fn query_take<T>(&self, sql: impl AsRef<str>, index: usize) -> Result<T> {
    let location = std::panic::Location::caller();
    // 错误时输出调用位置
    .map_err(|e| {
        error!("query_take error at {}: {}", location, e);
        anyhow::Error::from(e)
    })
}
```

### 错误重试机制

```rust
use aios_core::rs_surreal::ErrorHandler;

let handler = ErrorHandler::new(3, Duration::from_millis(100));
let result = handler.execute_with_retry(|| async {
    SUL_DB.query_take(sql, 0).await
}).await?;
```

---

## 代码位置

- **查询扩展**: `src/rs_surreal/query_ext.rs`
- **连接管理**: `src/rs_surreal/connection_manager.rs`
- **错误处理**: `src/rs_surreal/error_handler.rs`
- **层级查询优化**: `src/rs_surreal/graph.rs`
