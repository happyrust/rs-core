# 类型-属性映射机制分析

基于 IDA Pro 对 `core.dll` 的深入分析。

## 核心问题

**如何知道一个类型(noun)有哪些属性(attribute)？**

## attlib.dat 中的四个核心段

| 段名 | 含义 | 说明 |
|------|------|------|
| **ATGTIX** | Attribute/Noun Index | 属性索引表 |
| **ATGTDF** | Attribute/Noun Definitions | 属性定义表 |
| **ATGTSX** | Attribute/Noun Syntax | 类型-属性语法映射表 |
| **ATGTLT** | Type List | 类型列表 |

## 关键数据结构

### DB_Noun 结构 (1092 字节)

```c
struct DB_Noun {
    void **vftable;           // 0x00: 虚函数表
    char base_data[116];      // 0x04: 基础数据
    int type_id;              // 0x78: 类型ID
    // ...
    int hard_type;            // 0xB8: 硬类型指针
    // ...
    // offset 68-76: properties_ (vector<DB_Attribute*>)
    // ...
};
```

### 属性获取流程

```text
DB_Noun::validProperties()
    │
    ├─→ DB_Noun::internalGetField(240391897, &vector)
    │       │
    │       └─→ 从内部字段获取属性ID列表
    │
    └─→ 遍历属性ID列表
            │
            └─→ DB_Attribute_findAttribute_by_id(id, &attr)
                    │
                    └─→ 返回 DB_Attribute* 指针
```

## IDA Pro 关键函数

### 1. DB_Noun::validProperties (0x10459240)

获取类型的所有有效属性列表。

```c
vector<DB_Attribute*> DB_Noun::validProperties() {
    vector<DB_Attribute*> result;
    vector<int> attr_ids;
    
    // 从字段 240391897 获取属性ID列表
    internalGetField(240391897, &attr_ids);
    
    // 遍历ID列表，查找对应的属性
    for (int id : attr_ids) {
        DB_Attribute* attr;
        if (DB_Attribute_findAttribute_by_id(id, &attr)) {
            result.push_back(attr);
        }
    }
    
    return result;
}
```

### 2. DB_Noun::addProperty (0x1045BCA0)

向类型添加属性。

```c
void DB_Noun::addProperty(vector<DB_Noun*>& nouns, DB_Attribute* attr) {
    // 展开类型列表（包含继承类型）
    vector<DB_Noun*> expanded;
    expandList(nouns, &expanded);
    
    // 为每个类型添加属性
    for (DB_Noun* noun : expanded) {
        // 检查属性是否已存在
        auto& props = noun->properties_;  // offset 68
        if (find(props, attr) == props.end()) {
            props.push_back(attr);
        }
    }
}
```

### 3. ATTLIB_Load_Syntax_ATGTSX (0x108533B4)

加载类型-属性语法映射表。

```c
int ATTLIB_Load_Syntax_ATGTSX(
    int* start_page,
    int* attr_hashes,   // 输出: 属性哈希数组
    int* noun_hashes,   // 输出: 类型哈希数组
    int* max_count,
    int* actual_count
) {
    // 使用 FHDBRN 分页读取
    while (FHDBRN(&file, &page, buffer, &err)) {
        for (int j = 0; j < 512; ) {
            int val = buffer[j];
            
            if (val == -1 || val == 0) break;  // 段结束
            
            // 读取属性哈希和类型哈希
            attr_hashes[*actual_count] = val;
            noun_hashes[*actual_count] = buffer[j + 1];
            (*actual_count)++;
            
            j += 2;
        }
    }
}
```

### 4. sub_10851DA8 - ATGTLT 加载 (0x10851DA8)

加载类型列表，使用 XML 格式解析。

```c
// XML 格式示例:
// <EQUI noun="EQUIPMENT">...</EQUI>
// <NAME attribute="NAME" noun="EQUIPMENT">...</NAME>
```

## ATGTSX 语法表格式

### 记录结构

```text
每条记录: [attr_hash, noun_hash, extra_info]
         4字节      4字节      4字节

attr_hash: 属性的27进制哈希值
noun_hash: 类型的27进制哈希值
extra_info: 额外信息（如数组索引）
```

### 页面布局

```text
页面结构 (2048 字节 = 512 字):
┌─────────────────────────────────────┐
│ record[0]: attr_hash, noun_hash, ...│
│ record[1]: attr_hash, noun_hash, ...│
│ ...                                 │
│ 0x00000000 (页切换标记)             │
│ 或 0xFFFFFFFF (段结束标记)          │
└─────────────────────────────────────┘
```

## 实际数据示例

从 `attlib.dat` 段 3 (ATGTSX, 页 2123) 读取：

```text
位置  值           含义
[0]   0x0015C886   属性哈希
[1]   0x000012CB   类型哈希
[2]   0x00000006   额外信息

[3]   0x0015C8FF   属性哈希
[4]   0x000010DD   类型哈希
[5]   0x00000006   额外信息
...
```

## 类型继承

PDMS 类型系统支持继承，获取属性时需要考虑：

```text
EQUI (设备)
  └── NOZZ (接管)
        └── 继承 EQUI 的属性
        └── 自己特有的属性
```

`DB_Noun::expandList()` 函数负责展开继承链。

## 属性查找流程

```text
用户请求: 获取 EQUI 的所有属性

1. 调用 DB_Noun::validProperties()

2. 获取 EQUI 的属性ID列表 (字段 240391897)
   → 返回: [hash1, hash2, hash3, ...]

3. 对每个 hash 调用 DB_Attribute_findAttribute_by_id()
   → 首先在内存缓存中查找
   → 如果 hash <= 387951929, 从 ATGTDF 加载
   → 否则使用 oldKey 字典查找

4. 返回 vector<DB_Attribute*>
```

## 代码实现建议

### 加载 ATGTSX 段

```rust
/// ATGTSX 语法表条目
pub struct AttlibSyntaxEntry {
    pub attr_hash: u32,    // 属性哈希
    pub noun_hash: u32,    // 类型哈希
    pub extra_info: u32,   // 额外信息
}

/// 加载 ATGTSX 段
fn load_atgtsx(&mut self, start_page: u32) -> std::io::Result<Vec<AttlibSyntaxEntry>> {
    let mut entries = Vec::new();
    let mut cursor = WordCursor::new(self, start_page)?;
    
    loop {
        let attr_hash = cursor.next_word(self)?;
        
        if attr_hash == PAGE_SWITCH_MARK {
            cursor.advance_page(self)?;
            continue;
        }
        
        if attr_hash == SEGMENT_END_MARK {
            break;
        }
        
        let noun_hash = cursor.next_word(self)?;
        let extra_info = cursor.next_word(self)?;
        
        entries.push(AttlibSyntaxEntry {
            attr_hash,
            noun_hash,
            extra_info,
        });
    }
    
    Ok(entries)
}
```

### 构建类型-属性映射

```rust
/// 类型-属性映射
pub struct NounAttributeMap {
    /// noun_hash → Vec<attr_hash>
    pub mapping: HashMap<u32, Vec<u32>>,
}

impl NounAttributeMap {
    pub fn from_syntax(entries: &[AttlibSyntaxEntry]) -> Self {
        let mut mapping: HashMap<u32, Vec<u32>> = HashMap::new();
        
        for entry in entries {
            mapping
                .entry(entry.noun_hash)
                .or_default()
                .push(entry.attr_hash);
        }
        
        Self { mapping }
    }
    
    /// 获取类型的所有属性
    pub fn get_attributes(&self, noun_hash: u32) -> Vec<u32> {
        self.mapping.get(&noun_hash).cloned().unwrap_or_default()
    }
}
```

## 相关 IDA 函数地址

| 函数 | 地址 | 说明 |
|------|------|------|
| DB_Noun::validProperties | 0x10459240 | 获取有效属性 |
| DB_Noun::addProperty | 0x1045BCA0 | 添加属性 |
| DB_Noun::internalGetField | 0x10457BE0 | 内部字段获取 |
| DB_Attribute_findAttribute_by_id | 0x1045E5F0 | 通过ID查找属性 |
| ATTLIB_Load_Index_ATGTIX | 0x10852A64 | 加载属性索引 |
| ATTLIB_Load_Def_ATGTDF | 0x10852E20 | 加载属性定义 |
| ATTLIB_Load_Syntax_ATGTSX | 0x108533B4 | 加载语法表 |
| sub_10851DA8 (ATGTLT) | 0x10851DA8 | 加载类型列表 |

## 总结

1. **类型的属性列表**存储在 `ATGTSX` 语法表中
2. 每条记录包含 `[attr_hash, noun_hash]` 映射
3. 运行时通过 `DB_Noun::validProperties()` 获取
4. 属性定义（类型、默认值）存储在 `ATGTDF` 段
5. 属性索引存储在 `ATGTIX` 段
