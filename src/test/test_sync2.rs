use std::collections::BTreeMap;  // 使用BTreeMap
use std::{fs, fs::File};  // 使用File和BTreeSet
use std::io::Write;  // 使用Write trait
use nom::AsBytes;  // 使用AsBytes trait
use syn::{DeriveInput, parse_quote};  // 使用syn库中的相关类型和宏
use quote::quote;  // 使用quote宏
use syn::Ident;  // 使用Ident类型
use proc_macro2::Span;  // 使用Span类型
use crate::get_default_pdms_db_info;  // 使用get_default_pdms_db_info函数
use crate::tool::db_tool::db1_dehash;  // 使用db1_dehash函数
use rust_format::{Formatter, RustFmt};  // 使用Formatter和RustFmt类型
use crate::pdms_types::AttrInfo;
// 使用Formatter和RustFmt类型
use crate::types::attval::AttrVal;  // 使用AttrVal和AttrInfo类型

#[test]
fn test_gen_att_type_structs() {
    let mut ast: DeriveInput = parse_quote! {
        #[serde_as]
        #[derive(Serialize, Deserialize, Clone, Debug, Default, DeriveEntityModel, Reflect)]
        #[sea_orm(table_name = "PdmsElement")]
        #[reflect(Default, DbOpTrait)]
        pub struct Model {
            #[sea_orm(primary_key, auto_increment = false)]
            pub id: String,
            pub REFNO: RefU64,
            pub NAME: String,
            pub OWNER: RefU64,
            pub TYPE: String,
        }
    };

    let db_info = get_default_pdms_db_info();  // 获取默认的数据库信息
    let mut mods_content = vec![];
    let mut entites_content = vec![];
    let mut type_registry_content = vec![];
    let mut type_cache_content = vec![];

    fs::create_dir_all("src/orm/generated");

    for noun_att_info in &db_info.noun_attr_info_map {  // 遍历数据库中的名词属性信息
        if *noun_att_info.key() < 0 {  // 如果属性信息小于0，则跳过
            continue;
        }

        let type_name = db1_dehash(*noun_att_info.key() as _);  // 获取属性类型名
        if type_name == "" {
            continue;
        }
        mods_content.push(format!("pub mod {};", &type_name));
        type_registry_content.push(format!("type_registry.register::<{}::Model>();", &type_name));
        type_cache_content.push(format!("type_cache.type_id_of::<{}::Model>();", &type_name));
        entites_content.push(format!("pub use super::{}::Entity as {};", &type_name, &type_name));

        // if type_name.as_str() != "CYLI" {  // 如果属性类型名不是"BOX"，则跳过
        //     continue;
        // }

        let mut new_ast = ast.clone();  // 克隆ast生成新的语法树

        if let syn::Data::Struct(ref mut s) = &mut new_ast.data {  // 如果ast是结构体类型
            if let syn::Fields::Named(n) = &mut s.fields {  // 如果ast的字段是命名字段
                let bmap: BTreeMap<String, AttrInfo> = noun_att_info.iter().map(|x| (x.name.clone(), x.clone())).collect();  // 创建BTreeMap用于存储属性信息

                for (name, val) in bmap {  // 遍历属性信息的键值对
                    if name == "NAME" || name == "TYPE" || name == "OWNER"
                        || name.contains(":") || name.contains("@")  {  // 如果属性名是"NAME"或"TYPE"，则跳过
                        continue;
                    }

                    let mut field = n.named[2].clone();  // 克隆第三个字段
                    field.ident = Some(Ident::new(name.as_str(), Span::call_site()));  // 将字段的标识符修改为属性名

                    match val.default_val {  // 根据属性值的类型进行匹配
                        AttrVal::StringType(_) | AttrVal::ElementType(_) | AttrVal::WordType(_) => {}  // 如果是字符串类型、元素类型或单词类型，则不做修改
                        AttrVal::IntegerType(_) => field.ty = parse_quote!(i32),  // 如果是整数类型，则将字段类型修改为i32
                        AttrVal::BoolType(_) => field.ty = parse_quote!(bool),  // 如果是布尔类型，则将字段类型修改为bool
                        AttrVal::BoolArrayType(_) => field.ty = parse_quote!(BoolVec),  // 如果是布尔数组类型，则将字段类型修改为BoolVec
                        AttrVal::DoubleType(_) => field.ty = parse_quote!(f32),  // 如果是浮点数类型，则将字段类型修改为f32
                        AttrVal::Vec3Type(_) | AttrVal::DoubleArrayType(_) => field.ty = parse_quote!(F32Vec),  // 如果是Vec3类型或双精度数组类型，则将字段类型修改为F32Vec
                        AttrVal::IntArrayType(_) => field.ty = parse_quote!(I32Vec),  // 如果是整数数组类型，则将字段类型修改为I32Vec
                        AttrVal::RefU64Type(_) => field.ty = parse_quote!(RefU64),  // 如果是RefU64类型，则将字段类型修改为RefU64
                        _ => {
                            dbg!(&val);
                        }
                    }

                    n.named.push(field);  // 将修改后的字段添加到命名字段中
                }
            }
        }

        let token_stream = quote! { #new_ast };  // 将新的语法树转换为TokenStream

        let file_path = format!("src/orm/generated/{}.rs", &type_name);  // 生成文件路径
        let mut file = File::create(file_path).unwrap();  // 创建文件
        let mut actual: String = RustFmt::default().format_str(token_stream.to_string()).unwrap();  // 格式化生成的代码字符串
        actual = actual.replace(r#"table_name = "PdmsElement""#, &format!(r#"table_name = "{}""#, &type_name));  // 将表名修改为属性名

        file.write(r#"
// ****Auto generated by syn

use crate::orm::types::*;
use crate::types::*;
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use bevy_reflect::{Reflect, Struct, DynamicStruct, Typed, std_traits::ReflectDefault};
use sea_orm::{DatabaseBackend, QueryTrait, Schema};
use crate::orm::traits::{DbOpTrait, ReflectDbOpTrait};
use crate::impl_db_op_trait;


        "#.as_bytes()).unwrap();  // 写入引用的库和模块

        file.write(actual.as_bytes()).unwrap();  // 写入生成的代码

        file.write(r#"
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}
impl ActiveModelBehavior for ActiveModel {}

impl_db_op_trait!();
        "#.as_bytes()).unwrap();  // 写入额外的代码

        println!("{}", token_stream);  // 打印TokenStream
    }


    let file_path = format!("src/orm/generated/mod.rs");  // 生成文件路径
    let mut file = File::create(file_path).unwrap();  // 创建文件
    file.write(mods_content.join("\r\n").as_bytes());

    let file_path = format!("src/orm/template/{}_ents.rs", "template");  // 生成文件路径
    let mut file = File::create(file_path).unwrap();  // 创建文件
    let _ = file.write(entites_content.join("\r\n").as_bytes());


    let file_path = format!("src/orm/template/{}_regs.rs", "template");  // 生成文件路径
    let mut file = File::create(file_path).unwrap();  // 创建文件
    let _ = file.write(type_registry_content.join("\r\n").as_bytes());

    let file_path = format!("src/orm/template/{}_cache.rs", "template");  // 生成文件路径
    let mut file = File::create(file_path).unwrap();  // 创建文件
    let _ = file.write(type_cache_content.join("\r\n").as_bytes());

    //type_cache_content

    // if let syn::Data::Struct(mut s) = ast.data.clone(){  // 如果ast是结构体类型
    //     if let syn::Fields::Named(n) = &mut s.fields {  // 如果ast的字段是命名字段
    //         let mut field = n.named[1].clone();  // 克隆第二个字段
    //         field.ident = Some(Ident::new("NAME", Span::call_site()));  // 将字段的标识符修改为"NAME"
    //         n.named.push(field);  // 将修改后的字段添加到命名字段中
    //     }
    // }
    //
    // let token_stream = quote! { #ast };  // 将ast转换为TokenStream

    // Print the TokenStream
    // println!("{}", token_stream);
}